[
  {
    "timestamp": "2025-01-29T14:12:39.503354",
    "response": {
      "id": "chatcmpl-Auxw3ItNkK8vfr0yqO2AyuDcdv7GC",
      "choices": [
        {
          "finish_reason": "stop",
          "index": 0,
          "logprobs": null,
          "message": {
            "content": "Below is a step-by-step recipe you can follow to:\n\n1) Fetch the last 5 open tickets.  \n2) Extract the project ID from each ticket description.  \n3) Look up the project's most recent plan.  \n4) Classify each ticket into a category (downtime, reliability, performance, bug, feature request, others).  \n5) Sort these tickets according to your custom priority criteria.  \n6) Output the sorted list of ticket IDs in the requested format.\n\n--------------------------------------------------------------------------------\n1) Fetch the last 5 open tickets:\n--------------------------------------------------------------------------------\nUse the support tickets database. For example:\n\nSELECT\n  id,\n  subject,\n  description,\n  created_at\nFROM support_ticket\nWHERE status = 'open'\nORDER BY created_at DESC\nLIMIT 5;\n\nThis query returns the most recently created five tickets that are still open.\n\n--------------------------------------------------------------------------------\n2) Extract the project ID from each ticket description\n--------------------------------------------------------------------------------\nProject IDs are UUIDs. You can pull them out by applying a regex to the description\nin your application logic (or use a database function if desired). For instance,\nin many programming environments, you might do something like:\n\n\u2022 Pseudocode:\n\n  ticket_description = row.description\n  match_uuid = regex_search(ticket_description, r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', 'i')\n  project_id = match_uuid if found else null\n\n(If your descriptions contain more than one UUID, pick the one that represents\nthe relevant project.)\n\n--------------------------------------------------------------------------------\n3) Look up the project\u2019s most recent plan\n--------------------------------------------------------------------------------\nFor each extracted project_id, query the control plane database to determine the\nproject\u2019s current (most recent) plan. One way is to look up the last entry in\nproject_plan_changelogs for that project and join on plans:\n\n  SELECT ppc.project_id,\n         p.name AS plan_name\n  FROM project_plan_changelogs ppc\n  JOIN plans p ON ppc.plan_id = p.id\n  WHERE ppc.project_id = '<project_uuid>'\n  ORDER BY ppc.created_at DESC\n  LIMIT 1;\n\nYou\u2019ll get the plan name (e.g. \u201cAdvanced Plan\u201d, \u201cBase Plan\u201d, etc.).\n\n--------------------------------------------------------------------------------\n4) Classify the ticket into a category\n--------------------------------------------------------------------------------\nExamine the subject/description (or internal notes) of the ticket to categorize\nit among:\n\u2022 downtime  \n\u2022 reliability  \n\u2022 performance  \n\u2022 bug  \n\u2022 feature request  \n\u2022 others  \n\nTypically, you\u2019d match certain keywords or parse the description to figure out\nthe correct category. For example:\n\u2022 If the description mentions \u201cwidespread outage,\u201d \u201cconsole not reachable,\u201d\n  \u201call queries failing,\u201d or similar high-severity text, you might pick \u201cdowntime.\u201d  \n\u2022 If the description references intermittent disruptions, random timeouts, or\n  stability concerns, you mark it \u201creliability.\u201d  \n\u2022 If the complaint is about slow GraphQL queries or increased latency, you might\n  pick \u201cperformance.\u201d  \n\u2022 If the user explicitly reports a \u201cbug\u201d (unexpected behavior, erroneous\n  responses, etc.), classify as \u201cbug.\u201d  \n\u2022 If the user is requesting a new feature or improvement, classify as\n  \u201cfeature request.\u201d  \n\u2022 Otherwise, \u201cothers.\u201d\n\n--------------------------------------------------------------------------------\n5) Sort the tickets by priority\n--------------------------------------------------------------------------------\nOnce you have for each ticket:\n\u2022 the plan name for its project (e.g. \u201cAdvanced Plan\u201d or \u201cBase Plan\u201d),  \n\u2022 the category you assigned,  \n\u2022 the created_at timestamp,\n\napply your custom sorting rules, in this exact order:\n\n1. If a ticket is on the \u201cAdvanced Plan\u201d AND its category is \u201cdowntime\u201d or \u201creliability,\u201d\n   it should rank above the others.  \n2. Next, if a ticket is on the \u201cBase Plan\u201d AND its category is \u201cdowntime\u201d or \u201creliability,\u201d\n   it should rank above the remaining.  \n3. Among whichever are left, prioritize by category in this order:\n   downtime > reliability > performance > bug > feature request > others  \n4. If there\u2019s still a tie, compare created_at: the older ticket (earlier created_at)\n   comes first.\n\n--------------------------------------------------------------------------------\n6) Return the final sorted list of ticket IDs\n--------------------------------------------------------------------------------\nAfter you have done the above, you will arrive at a final ordering of the 5 tickets.  \nReturn them as:\n\n<tickets>\nTICKET_ID_IN_FIRST_PLACE\nTICKET_ID_IN_SECOND_PLACE\nTICKET_ID_IN_THIRD_PLACE\nTICKET_ID_IN_FOURTH_PLACE\nTICKET_ID_IN_FIFTH_PLACE\n</tickets>\n\nWhere each line in between <tickets> and </tickets> is just one ticket\u2019s ID.\n\n--------------------------------------------------------------------------------\nPutting It All Together (Example)\n--------------------------------------------------------------------------------\nBelow is a hypothetical example showing the overall flow. Suppose the query in\nstep 1 returns these last 5 open tickets:\n\n ID |        subject               |         description                        |        created_at        \n----+------------------------------+--------------------------------------------+--------------------------\n 11 | \"Zero downtime?\"            | \"Project 11111111-2222-3333-4444-555555555555 is down...\" | 2023-10-09 09:00 UTC\n 23 | \"High latency\"              | \"We have project 123e4567-e89b-12d3-a456-426614174000...\"  | 2023-10-09 08:50 UTC\n 42 | \"Random outages\"            | \"Project ffffffff-aaaa-bbbb-cccc-dddddddddddd is acting up\" | 2023-10-09 08:45 UTC\n 47 | \"Strange error with _in op\" | \"We found a weird bug in project 22222222-aaaa-bbbb-cccc-ffffffffffff\" | 2023-10-09 08:40 UTC\n 55 | \"Requesting new feature\"     | \"We want batch operations for project 55555555-6666-7777-8888-999999999999\" | 2023-10-09 08:35 UTC\n\n1) Extract project_id from each:\n   \u2022 Ticket 11 \u2192 project_id = 11111111-2222-3333-4444-555555555555\n   \u2022 Ticket 23 \u2192 project_id = 123e4567-e89b-12d3-a456-426614174000\n   \u2022 Ticket 42 \u2192 project_id = ffffffff-aaaa-bbbb-cccc-dddddddddddd\n   \u2022 Ticket 47 \u2192 project_id = 22222222-aaaa-bbbb-cccc-ffffffffffff\n   \u2022 Ticket 55 \u2192 project_id = 55555555-6666-7777-8888-999999999999\n\n2) Look up the most recent plan for each project. Suppose we discover:\n   \u2022 11111111-2222-3333-4444-555555555555 \u2192 \"Advanced Plan\"\n   \u2022 123e4567-e89b-12d3-a456-426614174000 \u2192 \"Base Plan\"\n   \u2022 ffffffff-aaaa-bbbb-cccc-dddddddddddd \u2192 \"Advanced Plan\"\n   \u2022 22222222-aaaa-bbbb-cccc-ffffffffffff \u2192 \"Base Plan\"\n   \u2022 55555555-6666-7777-8888-999999999999 \u2192 \"Base Plan\"\n\n3) Classify each ticket:\n   - #11 \"Project is down\" \u2192 category = downtime\n   - #23 \"High latency\" \u2192 category = performance\n   - #42 \"Random outages\" \u2192 category = reliability\n   - #47 \"Weird bug\" \u2192 category = bug\n   - #55 \"Requesting new feature\" \u2192 category = feature request\n\n4) Apply your priority rules step by step:\n\n   (a) Advanced + (downtime or reliability) outranks everything.\n      - Ticket #11 (Advanced Plan + downtime)\n      - Ticket #42 (Advanced Plan + reliability)\n   (b) Base + (downtime or reliability) outranks everything left.\n      - (none here with downtime or reliability on a Base Plan)\n   (c) Among the rest, order by category (downtime > reliability > performance > bug > feature request > others).\n      - #23 performance (Base Plan)\n      - #47 bug (Base Plan)\n      - #55 feature request (Base Plan)\n\n   Finally, if still tied, prefer older (earlier created_at). Not needed here\n   because each ticket has a unique category.\n\n   So the final priority order:\n\n   1) Ticket 11  (Advanced, downtime)\n   2) Ticket 42  (Advanced, reliability)\n   3) Ticket 23  (Base, performance)\n   4) Ticket 47  (Base, bug)\n   5) Ticket 55  (Base, feature request)\n\n5) Output them as requested:\n\n<tickets>\n11\n42\n23\n47\n55\n</tickets>\n\n--------------------------------------------------------------------------------\nThat\u2019s it! You can adapt the same logic to your actual data, classification\nheuristics, and plan names.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
          }
        }
      ],
      "created": 1738140123,
      "model": "o1-2024-12-17",
      "object": "chat.completion",
      "service_tier": "default",
      "system_fingerprint": "fp_d91c966719",
      "usage": {
        "completion_tokens": 4298,
        "prompt_tokens": 1037,
        "total_tokens": 5335,
        "completion_tokens_details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 2368,
          "rejected_prediction_tokens": 0
        },
        "prompt_tokens_details": {
          "audio_tokens": 0,
          "cached_tokens": 0
        }
      }
    }
  }
]