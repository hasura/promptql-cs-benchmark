Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 20 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is an illustrative example of how you might produce and return the top 5 open support tickets (by ticket ID) according to the specified priority rules. Because we do not have actual data, the ticket IDs are simply sample placeholders to demonstrate the sorting logic. In a real scenario, you would run actual queries against both databases, parse out the project IDs, fetch the most recent plan for each project, classify the ticket, and then apply the priority rules to return the top 5.

────────────────────────────────────────────────────────────────────────────
1) Retrieve the last 20 open tickets from the Support Tickets Database:
────────────────────────────────────────────────────────────────────────────

Use a read-only query to get up to 20 tickets that have "status = 'open'", ordered by creation date (descending).

Example query:

SELECT
  id,
  subject,
  description,
  created_at
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 20;

────────────────────────────────────────────────────────────────────────────
2) Extract the Project ID (UUID) from each ticket description.
────────────────────────────────────────────────────────────────────────────

In PostgreSQL, you can attempt something like:

SELECT
  id,
  subject,
  description,
  created_at,
  substring(description FROM '([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})') AS project_id
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 20;

If the ticket description includes a valid UUID (e.g. "Project ID: 7e96beac-47e2-469f-8940-bfb0aac5c3b9"), the above substring(...) call will capture it as “project_id.”

────────────────────────────────────────────────────────────────────────────
3) For each extracted project_id, get the most recent plan from the Control Plane Database.
────────────────────────────────────────────────────────────────────────────

For each project_id found above, run a query against the control plane to find the most recent plan:

SELECT
  p.name AS plan_name
FROM project_plan_changelogs ppc
JOIN plans p ON p.id = ppc.plan_id
WHERE ppc.project_id = '<the_project_uuid>'
ORDER BY ppc.created_at DESC
LIMIT 1;

────────────────────────────────────────────────────────────────────────────
4) Classify the ticket into one of the categories.
────────────────────────────────────────────────────────────────────────────

Look for key terms in the ticket’s subject or description to classify as one of:
• downtime
• reliability
• performance
• bug
• feature request
• others

Example pseudocode for classification:

CASE
  WHEN description ILIKE '%inability to access%' 
    OR description ILIKE '%500 error%' 
    OR description ILIKE '%timeout%' 
    OR description ILIKE '%widespread service disruptions%'
    THEN 'downtime'
  WHEN description ILIKE '%random request failures%' 
    OR description ILIKE '%intermittent%' 
    OR description ILIKE '%service instability%'
    THEN 'reliability'
  WHEN description ILIKE '%performance%' 
    OR description ILIKE '%latency%' 
    OR description ILIKE '%taking several seconds%'
    THEN 'performance'
  WHEN description ILIKE '%bug%'
    OR description ILIKE '%unauthorized access%' 
    OR description ILIKE '%wrong results%'
    THEN 'bug'
  WHEN description ILIKE '%feature request%' 
    OR description ILIKE '%enhancement%' 
    OR description ILIKE '%improvement%'
    THEN 'feature request'
  ELSE 'others'
END

────────────────────────────────────────────────────────────────────────────
5) Apply the priority rules and pick the top 5.
────────────────────────────────────────────────────────────────────────────

Priority rules (in order, break ties by moving to the next rule):
1. A ticket on the advanced plan with category ('downtime' or 'reliability') is higher priority.
2. A ticket on the base plan with category ('downtime' or 'reliability') is next.
3. Among all other tickets, sort categories as: downtime > reliability > performance > bug > feature request > others.
4. If there is still a tie, prioritize the older ticket (earlier created_at).

In practice, you can implement this in your application logic or craft a complex ORDER BY in SQL. Pseudocode for sorting:

ORDER BY
  -- (1) advanced + (downtime or reliability)
  CASE WHEN plan_name ILIKE '%advanced%' 
        AND (category IN ('downtime','reliability')) THEN 1 ELSE 0 END DESC,
  -- (2) base + (downtime or reliability)
  CASE WHEN plan_name ILIKE '%base%' 
        AND (category IN ('downtime','reliability')) THEN 1 ELSE 0 END DESC,
  -- (3) category priority
  CASE category
    WHEN 'downtime' THEN 1
    WHEN 'reliability' THEN 2
    WHEN 'performance' THEN 3
    WHEN 'bug' THEN 4
    WHEN 'feature request' THEN 5
    ELSE 6
  END ASC,
  -- (4) older tickets first
  created_at ASC

Finally, retrieve the top 5 ticket IDs after applying the sort criteria.

────────────────────────────────────────────────────────────────────────────
Example: Final Top 5 Tickets in Priority Order
────────────────────────────────────────────────────────────────────────────

For demonstration only, assume we have these 8 open tickets (IDs 101–108), with extracted plan_name and assigned category:

• Ticket 101: 
  – plan_name = 'Advanced'
  – category = 'downtime'
  – created_at = older
• Ticket 102: 
  – plan_name = 'Advanced'
  – category = 'reliability'
  – created_at = newer
• Ticket 103: 
  – plan_name = 'Advanced'
  – category = 'performance'
• Ticket 104: 
  – plan_name = 'Base'
  – category = 'reliability'
• Ticket 105: 
  – plan_name = 'Base'
  – category = 'downtime'
• Ticket 106: 
  – plan_name = 'Advanced'
  – category = 'bug'
• Ticket 107: 
  – plan_name = 'Advanced'
  – category = 'feature request'
• Ticket 108: 
  – plan_name = 'Base'
  – category = 'others'

Applying the rules:
1) Advanced & (downtime or reliability): #101 (downtime, older) > #102 (reliability, newer)
2) Base & (downtime or reliability): #105 (downtime) > #104 (reliability)
3) Then apply category order among the rest:
   #103 (performance) > #106 (bug) > #107 (feature request) > #108 (others)
4) Within each category, older ticket first (if there’s a tie).

Hence the top 5 (in order) become:
101, 102, 105, 104, 103

Putting them in the requested output format:

<tickets>
101
102
105
104
103
</tickets>

────────────────────────────────────────────────────────────────────────────
Remember, in a real scenario you will:
• Execute the queries against your databases. 
• Parse out the project IDs from descriptions. 
• Fetch the corresponding plan. 
• Classify tickets. 
• Sort according to the rules. 
• Finally, return the top 5 ticket IDs as shown above.
────────────────────────────────────────────────────────────────────────────