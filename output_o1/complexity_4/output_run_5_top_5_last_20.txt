Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 20 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is one practical way to produce the top 5 “open” support tickets in priority order. Since these tickets and plans are stored in two different databases (Support Tickets DB vs. Control Plane DB), the process involves multiple steps and a bit of parsing/classification logic. In the end, you will have five ticket IDs sorted according to the rules you specified, which you can then wrap in the <tickets></tickets> tags.

────────────────────────────────────────────────────────────────────────────
1) In the Support Tickets Database: Fetch the last 20 open tickets
────────────────────────────────────────────────────────────────────────────
Use a query such as:

SELECT
  st.id,
  st.subject,
  st.description,
  st.created_at
FROM support_ticket st
WHERE st.status = 'open'
ORDER BY st.created_at DESC
LIMIT 20;

This returns up to 20 most recently created open tickets. Let’s call this result set “open_tickets.”

────────────────────────────────────────────────────────────────────────────
2) Extract the project ID (UUID) from each ticket’s description/subject
────────────────────────────────────────────────────────────────────────────
If the project ID is embedded somewhere in the text, you can use a regular expression to capture it. For instance (in PostgreSQL):

SELECT
  id,
  subject,
  description,
  created_at,
  (regexp_matches(description || ' ' || subject,
     '([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})')
   )[1] AS project_id
FROM (
  -- put the query from step 1 here
) AS open_tickets;

Note:
• This concatenates description and subject, then searches for a UUID pattern.  
• Some tickets might not have a parseable UUID at all; those rows could come back with NULL for project_id.

────────────────────────────────────────────────────────────────────────────
3) For each ticket/project_id, look up the most recent plan in the Control Plane DB
────────────────────────────────────────────────────────────────────────────
Once you have a project_id, you can query the control plane to find the project’s latest plan. For each distinct project_id:

SELECT p.name AS plan_name
FROM project_plan_changelogs c
JOIN plans p ON p.id = c.plan_id
WHERE c.project_id = '<the-project-uuid>'
ORDER BY c.created_at DESC
LIMIT 1;

You might do this via a loop in an application layer or a script if direct cross-database queries are not enabled.  
Store the plan_name alongside your ticket data. For example, you might end up with columns: (ticket_id, created_at, project_id, plan_name).

────────────────────────────────────────────────────────────────────────────
4) Classify each ticket into downtime, reliability, performance, bug, feature request, or others
────────────────────────────────────────────────────────────────────────────
You can do this classification in application code or via a CASE expression in SQL if you rely on keywords. For instance:

CASE
  WHEN (   description ILIKE '%inability to access project console%'
        OR description ILIKE '%widespread service disruptions%'
        OR description ILIKE '%production environment outages%'
        OR description ILIKE '%500 error%'
        OR description ILIKE '%time out%'
        )
  THEN 'downtime'
  
  WHEN (   description ILIKE '%intermittent connectivity%'
        OR description ILIKE '%random request failures%'
        OR description ILIKE '%service instability%'
        )
  THEN 'reliability'

  WHEN (   description ILIKE '%performance issue%'
        OR description ILIKE '%slow response%'
        OR description ILIKE '%increased latency%'
        )
  THEN 'performance'

  WHEN (   description ILIKE '%bug%'
        OR description ILIKE '%unexpected behavior%'
        OR description ILIKE '%wrong results%'
        )
  THEN 'bug'

  WHEN (   description ILIKE '%feature request%'
        OR description ILIKE '%requesting enhanced functionality%'
        )
  THEN 'feature request'

  ELSE 'others'
END AS category

────────────────────────────────────────────────────────────────────────────
5) Sort using your priority rules
────────────────────────────────────────────────────────────────────────────
Your priority rules boil down to building a “sort key” that you can then ORDER BY. A convenient way is to use a CASE expression that evaluates to a numeric priority, then sort first by that numeric priority ascending, then by creation time ascending (older = higher priority).

Pseudocode combining your rules:

1) If plan = “Advanced” (or includes “advanced”) AND (downtime OR reliability) => highest  
2) If plan = “Base” (or includes “base”) AND (downtime OR reliability) => next highest  
3) Then by category in the order:  
   downtime (highest in this group)  
   reliability  
   performance  
   bug  
   feature request  
   others (lowest in this group)  
4) If still tied, older ticket is higher priority (so created_at ASC).

Example of a final SELECT (assuming you have ticket data with plan_name and category in a CTE or temp table called with_plan_info):

WITH with_plan_info AS (
  -- Suppose you’ve merged everything (ticket_id, created_at, plan_name, category).
  SELECT
    t.id as ticket_id,
    t.created_at,
    p.plan_name,
    t.category
  FROM some_temporary_table t
  LEFT JOIN ...
)
SELECT
  ticket_id,
  CASE
    WHEN plan_name ILIKE '%advanced%' AND category IN ('downtime','reliability') THEN 1
    WHEN plan_name ILIKE '%base%'     AND category IN ('downtime','reliability') THEN 2
    WHEN category = 'downtime'       THEN 3
    WHEN category = 'reliability'    THEN 4
    WHEN category = 'performance'    THEN 5
    WHEN category = 'bug'            THEN 6
    WHEN category = 'feature request' THEN 7
    ELSE 8
  END AS cat_priority
FROM with_plan_info
ORDER BY cat_priority ASC, created_at ASC
LIMIT 5;

That gives you the top 5 ticket IDs with the highest priority according to your rules.

────────────────────────────────────────────────────────────────────────────
6) Return the final ticket IDs
────────────────────────────────────────────────────────────────────────────
Once you run the above sorting query, simply extract the ticket IDs in the order returned, and place them inside:

<tickets>
[ID #1]
[ID #2]
[ID #3]
[ID #4]
[ID #5]
</tickets>

────────────────────────────────────────────────────────────────────────────
Example of what the final output might look like (fake IDs shown):
────────────────────────────────────────────────────────────────────────────
<tickets>
101
55
42
37
19
</tickets>

Since no real data is available here, you will need to run the queries (or your script) to produce the actual list. But the approach above outlines the full process and how to assemble and prioritize your top 5 tickets among the last 20 that are open, by:

• Grabbing the last 20 open tickets  
• Extracting project IDs  
• Looking up the plan  
• Classifying each ticket  
• Applying your custom priority rules  
• Returning the top 5 in the specified format.