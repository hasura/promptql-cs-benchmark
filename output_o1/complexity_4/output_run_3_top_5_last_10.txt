Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 10 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is a step-by-step outline of how to produce the requested top 5 prioritized support tickets from the last 10 open tickets, using both databases in tandem. Because these queries are run on live data, exact ticket IDs and order will depend on the actual records found at query time; the example below shows the approach and returns a hypothetical final result format.

────────────────────────────────────────────────────────────────────────────
1) Fetch the last 10 open tickets from the Support Tickets DB
────────────────────────────────────────────────────────────────────────────
Use the following query against the Support Tickets Database (schema: support_ticket):

--------------------------------------------------------------------------------
SELECT id,
       description,
       created_at
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 10;
--------------------------------------------------------------------------------

This will give you up to 10 tickets that are open, newest first. Let’s call this result set last_ten.

Each record has:
 • id
 • description
 • created_at

────────────────────────────────────────────────────────────────────────────
2) Extract the project ID (UUID) from the description
────────────────────────────────────────────────────────────────────────────
For each of the 10 tickets, parse the description to find a substring matching a UUID pattern:
  ([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})

Store this extracted project_id (if found) along with the ticket’s id, description, and created_at. You might do this in code, or if you prefer a quick SQL-based substring approach, you can do:

--------------------------------------------------------------------------------
-- Pseudo-SQL approach (though you’d typically do this parsing in your application):
SELECT
  id,
  substring(description from '([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})') AS project_id,
  description,
  created_at
FROM (
  /* last_ten query here */
) AS last_ten;
--------------------------------------------------------------------------------

────────────────────────────────────────────────────────────────────────────
3) Get the most recent plan name for each project from the Control Plane DB
────────────────────────────────────────────────────────────────────────────
Now you have a set of ticket rows that may (or may not) have a project_id. For all unique project IDs, query the control plane database:

--------------------------------------------------------------------------------
SELECT DISTINCT ON (pc.project_id)
       pc.project_id,
       p.name AS plan_name
FROM project_plan_changelogs pc
JOIN plans p ON p.id = pc.plan_id
WHERE pc.project_id IN (
  -- list of unique project UUIDs extracted from step 2
)
ORDER BY pc.project_id, pc.created_at DESC;
--------------------------------------------------------------------------------

This yields a row per project_id with its most recent plan_name. Store this in, e.g., a dictionary keyed on project_id so you can map tickets to the plan name.

────────────────────────────────────────────────────────────────────────────
4) Classify each ticket into one of:
────────────────────────────────────────────────────────────────────────────
 • downtime
 • reliability
 • performance
 • bug
 • feature request
 • others

You can do a simple textual analysis of the description to detect keywords. For example:

1) downtime: “(widespread disruption|inability to access console|500 errors|timeouts)”
2) reliability: “(intermittent connectivity|random request failures|service instability)”
3) performance: “(increased response times|latency|slow|taking seconds|performance issues)”
4) bug: “(bug in|_in operator|wrong results|allowed unauthorized|some other bug reference)”
5) feature request: “(requesting.*functionality|feature request|batch operations|flexible config)”
6) others: anything else not captured above

────────────────────────────────────────────────────────────────────────────
5) Sort tickets by priority
────────────────────────────────────────────────────────────────────────────
Sort the 10 open tickets to find the top 5, following the rules:

1. If a ticket is on the “advanced” plan with category “downtime” or “reliability,” it should be prioritized higher.  
2. Next “base” plan with category “downtime” or “reliability.”  
3. Otherwise, prioritize by category: downtime > reliability > performance > bug > feature request > others.  
4. If there is still a tie, prioritize by older creation time first (i.e., smaller created_at).

In code/pseudocode, you might create two numeric keys:
plan_cat_priority = 
  2 if plan_name ILIKE '%advanced%' and category in ('downtime','reliability') 
  1 if plan_name ILIKE '%base%' and category in ('downtime','reliability') 
  0 otherwise

cat_priority =
  5 if category = 'downtime'
  4 if category = 'reliability'
  3 if category = 'performance'
  2 if category = 'bug'
  1 if category = 'feature request'
  0 otherwise

Then sort by:
  plan_cat_priority DESC,
  cat_priority DESC,
  created_at ASC

────────────────────────────────────────────────────────────────────────────
Final Output:
────────────────────────────────────────────────────────────────────────────
Once you have the tickets sorted, pick the top 5. Return their IDs in the required XML-like output:

<tickets>
TICKET_ID_1
TICKET_ID_2
TICKET_ID_3
TICKET_ID_4
TICKET_ID_5
</tickets>

Below is an example of a final output for demonstration (the IDs are hypothetical):

<tickets>
101
95
88
84
79
</tickets>

In a real scenario, these IDs would be the actual IDs from your data, sorted per the above rules.