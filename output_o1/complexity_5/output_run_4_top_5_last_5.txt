Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 5 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the free plan with category 'downtime', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is an illustrative example of how you might retrieve and prioritize your top 5 open tickets. Since there is no real data in this example, the final IDs and classification are hypothetical. In an actual deployment, you would:

1) Query the last 5 open tickets.  
2) Extract the project ID from each ticket’s description (using a UUID regex).  
3) Look up the project’s most recent plan from the control plane database.  
4) Classify each ticket into the requested categories (downtime, reliability, performance, bug, feature request, others).  
5) Sort them according to the rules provided.  
6) Return the finalized list in the requested XML-like format.

────────────────────────────────────────────────────────────────────────────────
1) Get the last 5 open tickets from the support tickets database:

  SELECT
    id,
    description,
    created_at
  FROM support_ticket
  WHERE status = 'open'
  ORDER BY created_at DESC
  LIMIT 5;

2) Extract the project UUID from each ticket’s description:

  -- Example approach using regular expressions in PostgreSQL
  WITH last_five AS (
    SELECT
      id,
      description,
      created_at,
      substring(description FROM '([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})') AS project_id
    FROM support_ticket
    WHERE status = 'open'
    ORDER BY created_at DESC
    LIMIT 5
  )
  SELECT * FROM last_five;

3) For each extracted project_id, get the most recent plan_id (and therefore plan name) from the project_plan_changelogs and plans tables in the control plane database:

  SELECT
    p.name AS plan_name
  FROM project_plan_changelogs ppc
  JOIN plans p
    ON ppc.plan_id = p.id
  WHERE ppc.project_id = :project_id
  ORDER BY ppc.created_at DESC
  LIMIT 1;

4) Classify each ticket by scanning the subject/description against your classification rules:
   • downtime  
   • reliability  
   • performance  
   • bug  
   • feature request  
   • others

5) Sort the 5 tickets according to the priority rules, comparing them pairwise in this order:
   (a) Tickets on the advanced plan with category 'downtime' or 'reliability' first.  
   (b) Then tickets on the base plan with category 'downtime' or 'reliability'.  
   (c) Then tickets on the free plan with category 'downtime'.  
   (d) Then by category order: downtime > reliability > performance > bug > feature request > others.  
   (e) In case of ties so far, compare creation times (older tickets first).

Example Illustration

Imagine you have 5 open tickets with the following details and derived fields:

Ticket #1  
• id = 101  
• description: “Our production environment is down for project 11111111-aaaa-bbbb-cccc-222222222222. …”  
• extracted project_id = 11111111-aaaa-bbbb-cccc-222222222222  
• plan_name = advanced  
• creation time = 2023-01-02 10:00:00 UTC  
• classified category = downtime  

Ticket #2  
• id = 202  
• description: “We sometimes see random request failures in project 22222222-aaaa-bbbb-cccc-333333333333. …”  
• extracted project_id = 22222222-aaaa-bbbb-cccc-333333333333  
• plan_name = free  
• creation time = 2023-01-03 09:00:00 UTC  
• classified category = reliability  

Ticket #3  
• id = 303  
• description: “We need new GraphQL features for project 33333333-aaaa-bbbb-cccc-444444444444 …”  
• extracted project_id = 33333333-aaaa-bbbb-cccc-444444444444  
• plan_name = advanced  
• creation time = 2023-01-03 08:00:00 UTC  
• classified category = feature request  

Ticket #4  
• id = 404  
• description: “High latency and queries timing out for project 44444444-aaaa-bbbb-cccc-555555555555 …”  
• extracted project_id = 44444444-aaaa-bbbb-cccc-555555555555  
• plan_name = base  
• creation time = 2023-01-02 20:00:00 UTC  
• classified category = performance  

Ticket #5  
• id = 505  
• description: “We discovered a bug with the Actions feature in project 55555555-aaaa-bbbb-cccc-666666666666 …”  
• extracted project_id = 55555555-aaaa-bbbb-cccc-666666666666  
• plan_name = base  
• creation time = 2023-01-01 12:00:00 UTC  
• classified category = bug  

Apply the Priority Sorting Rules

1. Advanced plan + downtime/reliability come first.  
   • Ticket #1 is advanced + downtime → highest priority  
   • Ticket #2 is free + reliability (not advanced, skip for this rule)  
   • Ticket #3 is advanced + feature request (not downtime/reliability, skip here)  
   • Ticket #4 is base + performance (skip)  
   • Ticket #5 is base + bug (skip)

2. Base plan + downtime/reliability next.  
   • None of these base-plan tickets (#4, #5) are downtime/reliability, so skip.

3. Free plan + downtime next.  
   • Ticket #2 is free + reliability, not downtime, so skip.

4. Then rank remaining by category order (downtime > reliability > performance > bug > feature request > others):  
   • Remaining tickets: #2 (reliability), #3 (feature request), #4 (performance), #5 (bug)  
   • Category order: downtime(1) > reliability(2) > performance(3) > bug(4) > feature request(5) > others(6)  
   • So we place #2 (reliability) first among these, then #4 (performance), then #5 (bug), then #3 (feature request).

5. If two tickets remain tied after category, compare creation times (older first). In this illustration, there’s no exact category tie, so we accept the category order.

Final priority order of ticket IDs:  
• (1) Ticket #1 (advanced + downtime)  
• (2) Ticket #2 (free + reliability)  
• (3) Ticket #4 (base + performance)  
• (4) Ticket #5 (base + bug)  
• (5) Ticket #3 (advanced + feature request)

Hence, the final sorted list:

<tickets>
101
202
404
505
303
</tickets>

In a live scenario, you would programmatically:
• Fetch the last 5 open tickets.  
• Extract their project UUIDs and look up their plans in the control plane database.  
• Match their subject/description to the relevant category.  
• Then apply the sorting rules to decide the order.  
• Finally, output the ticket IDs in the requested format.