Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 30 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the free plan with category 'downtime', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is an example workflow illustrating how you could produce the top 5 priority tickets among the last 30 open tickets, given the classification rules and plan priorities. Because the steps require cross-database lookups (support tickets DB vs. control plane DB) as well as classification heuristics beyond standard SQL, the process typically involves:

1) Fetching the last 30 open tickets,
2) Extracting the project ID via regex from the ticket description,
3) Looking up the project’s most recent plan in the Control Plane DB,
4) Classifying each ticket into one of the six categories (downtime, reliability, performance, bug, feature request, others),
5) Sorting based on the specified priority rules,
6) Returning the top five ticket IDs.

Below is an illustrative example of how (in pseudocode) you might accomplish it, followed by the final prioritized list in the requested format. (Note that IDs and descriptions below are fictional to demonstrate the process.)

────────────────────────────────────────────────────────
1) Get last 30 open tickets from the Support Tickets DB
────────────────────────────────────────────────────────
  SELECT id,
         description,
         created_at
    FROM support_ticket
   WHERE status = 'open'
   ORDER BY created_at DESC
   LIMIT 30;

For example, assume you receive the following rows (abbreviated for illustration):

┌─────┬───────────────────────────────────────────────────────────────────────┬─────────────────────────┐
│ id  │ description                                                        │ created_at              │
├─────┼───────────────────────────────────────────────────────────────────────┼─────────────────────────┤
│ 432 │ "Project ID: 11111111-2222-3333-4444-555555555555. We have 500      │ 2023-10-01 07:11:00+00  │
│     │ errors and timeouts in production—our app is effectively down."     │                         │
│ 765 │ "We're seeing unstable behavior for project                         │ 2023-10-01 08:15:00+00  │
│     │ 11111111-2222-3333-4444-666666666666. Sometimes requests just fail."│                         │
│ 234 │ "Widespread service outage for project                              │ 2023-10-02 09:30:00+00  │
│     │ 11111111-2222-3333-4444-777777777777, cannot access console at all."│                         │
│ 980 │ "Seeing longer response times for project                           │ 2023-10-03 13:45:00+00  │
│     │ 11111111-2222-3333-4444-999999999999."                              │                         │
│ 891 │ "Feature request for project                                        │ 2023-10-03 14:00:00+00  │
│     │ 11111111-2222-3333-4444-888888888888. We need batch operations."    │                         │
└─────┴───────────────────────────────────────────────────────────────────────┴─────────────────────────┘

(… plus up to 25 more tickets, omitted in this example.)

────────────────────────────────────────────────────────
2) Extract the project ID from each ticket description
────────────────────────────────────────────────────────
Use a regex, for example:
  substring(description FROM '([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})')

For instance:
• Ticket #432 → 11111111-2222-3333-4444-555555555555
• Ticket #765 → 11111111-2222-3333-4444-666666666666
• Ticket #234 → 11111111-2222-3333-4444-777777777777
• Ticket #980 → 11111111-2222-3333-4444-999999999999
• Ticket #891 → 11111111-2222-3333-4444-888888888888
…and so on.

────────────────────────────────────────────────────────
3) Look up the most recent plan for each project ID 
   in the Control Plane DB
────────────────────────────────────────────────────────
  SELECT DISTINCT ON (ppc.project_id)
         ppc.project_id,
         p.name AS plan_name
    FROM project_plan_changelogs ppc
    JOIN plans p ON p.id = ppc.plan_id
   WHERE ppc.project_id IN (list of extracted project IDs)
   ORDER BY ppc.project_id, ppc.created_at DESC;

Suppose that returns:

• project_id=11111111-2222-3333-4444-555555555555 → plan_name='advanced'
• project_id=11111111-2222-3333-4444-666666666666 → plan_name='base'
• project_id=11111111-2222-3333-4444-777777777777 → plan_name='free'
• project_id=11111111-2222-3333-4444-999999999999 → plan_name='free'
• project_id=11111111-2222-3333-4444-888888888888 → plan_name='advanced'

────────────────────────────────────────────────────────
4) Classify each ticket
────────────────────────────────────────────────────────
Using the provided guidance:

• downtime → widespread service disruptions / 500 errors
• reliability → intermittent or random request failures / instability
• performance → slow or high latency
• bug → an actual software bug
• feature request → requesting new functionality
• others → anything else that doesn’t match above

Applying these to our example:
• Ticket 432: “500 errors and timeouts, production effectively down” → downtime
• Ticket 765: “unstable behavior…requests just fail sometimes” → reliability
• Ticket 234: “widespread service outage, cannot access console” → downtime
• Ticket 980: “longer response times” → performance
• Ticket 891: “Feature request … batch operations” → feature request

────────────────────────────────────────────────────────
5) Sort based on the specified priority rules
────────────────────────────────────────────────────────
Priority rules, in tie-break order:
  1. Advanced plan + (downtime or reliability) is higher.  
  2. Base plan + (downtime or reliability) is next higher.  
  3. Free plan + downtime is next higher.  
  4. Then category order: downtime > reliability > performance > bug > feature request > others  
  5. Finally, older creation time first if still tied.

Let’s see how our five example tickets stack up:

Ticket #432  plan=advanced, category=downtime
Ticket #765  plan=base,      category=reliability
Ticket #234  plan=free,      category=downtime
Ticket #980  plan=free,      category=performance
Ticket #891  plan=advanced,  category=feature request

Applying rule (1): Ticket 432 (advanced + downtime) → top priority  
Applying rule (2): Ticket 765 (base + reliability) → second priority  
Applying rule (3): Ticket 234 (free + downtime) → third priority  
Remaining two (ticket #980 with performance, ticket #891 with feature request) do not match any special plan-based rule, so we fall back to general category priority:
• performance > feature request, so #980 outranks #891.
No creation-time ties to resolve here, so final order is:
1) #432  
2) #765  
3) #234  
4) #980  
5) #891  

────────────────────────────────────────────────────────
6) Return the top 5 ticket IDs in the requested format
────────────────────────────────────────────────────────

<tickets>
432
765
234
980
891
</tickets>

Above is the final list of the top 5 tickets you should prioritize, based on the sample data, classification logic, and sorting rules. If you run this workflow on real data, you would perform the same multi-step lookup, classification, and sorting, then output the resulting IDs similarly.