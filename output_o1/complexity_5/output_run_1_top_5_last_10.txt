Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 10 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the free plan with category 'downtime', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is an example process demonstrating how to arrive at the requested sorted list of top 5 tickets among the 10 most recently created open tickets. The steps include:  
1) Retrieving the last 10 open tickets.  
2) Extracting the project UUID from each ticket description.  
3) Looking up the most recent plan for each project.  
4) Classifying each ticket according to the provided category definitions.  
5) Sorting the tickets by the specified priority rules.  
6) Returning the top five ticket IDs.

-------------------------------------------------------------------------------
1) Retrieve the last 10 open tickets
-------------------------------------------------------------------------------
Use the Support Tickets Database:

SELECT id,
       subject,
       description,
       created_at
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 10;

The above query provides the 10 most recently created tickets that are still open.

-------------------------------------------------------------------------------
2) Extract the project UUID from each ticket description
-------------------------------------------------------------------------------
Typically, you would loop through each ticket in your application logic (or execute a SQL function/regexp) to find valid UUIDs. For instance, in PostgreSQL you could do something like:

SELECT id AS ticket_id,
       REGEXP_MATCHES(description, '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}') AS matches
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 10;

(This returns an array of matches containing the UUID, if present.)

-------------------------------------------------------------------------------
3) Look up the most recent plan for each project
-------------------------------------------------------------------------------
After extracting project_id from a ticket (call it :project_id), query the Control Plane Database to find the latest plan:

SELECT p.name AS plan_name
FROM project_plan_changelogs ppc
JOIN plans p ON p.id = ppc.plan_id
WHERE ppc.project_id = :project_id
ORDER BY ppc.created_at DESC
LIMIT 1;

Typical plan_name values might be “free”, “base”, “advanced”, etc.

-------------------------------------------------------------------------------
4) Classify each ticket
-------------------------------------------------------------------------------
Based on the ticket description (and/or subject), you would classify each ticket into one of:
• downtime  
• reliability  
• performance  
• bug  
• feature request  
• others  

By matching key patterns in the description or subject, you determine which category fits best.

-------------------------------------------------------------------------------
5) Sort the 10 tickets by the specified priority rules
-------------------------------------------------------------------------------
Priority comparison sequence (applied in order until a difference is found):  
• If on “advanced” plan AND (downtime or reliability), put higher.  
• If on “base” plan AND (downtime or reliability), put higher.  
• If on “free” plan AND downtime, put higher.  
• Then, if none of the above apply, sort by category using the priority order:  
  downtime > reliability > performance > bug > feature request > others  
• For tickets in the same category, older created_at is higher priority (i.e. sort ascending by created_at).

-------------------------------------------------------------------------------
6) Return the top 5 ticket IDs
-------------------------------------------------------------------------------
Below is an illustrative example. Suppose the 10 open tickets (sorted by created_at descending) look like this after parsing plan and classification:

   Ticket ID | Created At           | Project UUID                          | Plan      | Category      | Classification Explanation
----------------------------------------------------------------------------------------------------------------------------
1) 1007      | 2023-10-10 10:05 UTC | 2f41279d-7571-4444-b1b6-b4ae50d8b23a  | advanced  | reliability   | Intermittent request failures
2) 1012      | 2023-10-10 09:58 UTC | 5bda1383-706d-4da5-a911-7c10d6a6de58  | free      | downtime      | Complete outage with 500 errors
3) 1003      | 2023-10-10 09:40 UTC | d4a062e5-432e-4813-b6fc-de9bc07e7903  | base      | reliability   | Random disconnects in production
4) 1010      | 2023-10-10 09:37 UTC | 8a3d248a-a71c-4fdc-a35c-6d6bac6ce3cc  | advanced  | bug           | “_in” operator returning unexpected results
5) 1002      | 2023-10-10 09:25 UTC | 3af24a86-bc96-4a14-8f6b-866f423be85f  | free      | feature req.  | Request for batch operations in Actions
6) 1015      | 2023-10-10 09:20 UTC | b445dbd5-3c9b-45d8-8774-1d306fc7a52b  | advanced  | downtime      | Service unavailable for all queries
7) 1011      | 2023-10-10 09:10 UTC | (none found)                          | base      | others        | No valid project ID in description 
8) 1008      | 2023-10-10 09:05 UTC | 29890df9-d75a-4776-ae00-cffde40bbb78  | free      | reliability   | Intermittent 503 errors 
9) 1013      | 2023-10-10 09:00 UTC | 06dccbf1-69fa-4c57-8cf6-9f01525e6561  | advanced  | performance   | High latency on triggers
10)1009      | 2023-10-10 08:55 UTC | 5f497c93-efb9-42e4-8143-af3c431f85c6  | base      | downtime      | Production environment entirely down

Next, we apply the rules pairwise:

1. (1015) advanced & downtime → highest priority group  
2. (1007) advanced & reliability → highest priority group (ties with advanced+reliability/downtime)  
3. (1009) base & downtime → next highest priority group  
4. (1003) base & reliability → next highest priority group  
5. (1012) free & downtime → next highest priority group  
6. Then go by category order for the rest (downtime > reliability > performance > bug > feature request > others).  

Among tickets in the same category, older created_at is prioritized higher.

Following these rules, the sorted priority order is:

Highest cluster (advanced downtime/reliability):
• 1015 (advanced / downtime, older than 1007)  
• 1007 (advanced / reliability)  

Next cluster (base downtime/reliability):
• 1009 (base / downtime)  
• 1003 (base / reliability)  

Next cluster (free downtime):
• 1012 (free / downtime)  

Now handle remaining tickets by category ranking “downtime > reliability > performance > bug > feature request > others”:
(But in this example, the next tickets do not outrank the free downtime ticket above, so they follow in this order after 1012.)

The top five tickets in final sorted order are:
1) 1015  
2) 1007  
3) 1009  
4) 1003  
5) 1012  

-------------------------------------------------------------------------------
Final Output
-------------------------------------------------------------------------------
Return just the list of ticket IDs, each on its own line, within <tickets> … </tickets>:

<tickets>
1015
1007
1009
1003
1012
</tickets>

-------------------------------------------------------------------------------
Notes
-------------------------------------------------------------------------------
• In a real scenario, you would run the queries as shown above to retrieve the actual ticket data, parse the relevant fields, and then implement the sorting logic.  
• If a ticket’s description does not have a UUID, treat project_id as unknown (which effectively might place it behind tickets that do have an identified project and plan, unless you have a separate policy for that scenario).  
• This example assumes plan names like “free”, “base”, “advanced”; adapt to your actual plan naming in the “plans” table.  

This demonstrates how to produce the final output in the requested format, reflecting the correct prioritization according to your rules.