Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 20 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the base plan with category 'downtime' or 'reliability', it should be prioritized higher.
- If a ticket is on the free plan with category 'downtime', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is an outline of how you can derive the top 5 tickets to prioritize, given the requirements. Because actual data is not provided here, the example at the end shows how the final output might look once you run these queries and apply the classification and sorting rules on real data.

────────────────────────────────────────────────────────────────────────
1) Fetch the last 20 open tickets
────────────────────────────────────────────────────────────────────────
Use your Support Tickets database to retrieve up to 20 “open” tickets. For simplicity, we include only the columns necessary (feel free to select additional columns if they’re useful):

-------------------------------------------
SELECT 
  id, 
  subject, 
  description, 
  created_at
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 20;
-------------------------------------------

This will give you the most recently created 20 open tickets (or fewer if fewer than 20 are open).

────────────────────────────────────────────────────────────────────────
2) Extract the Project ID (UUID) from each ticket’s description
────────────────────────────────────────────────────────────────────────
For each ticket’s “description” text, scan for a UUID using a pattern like:

-------------------------------------------
([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})
-------------------------------------------

If no match is found, treat the project_id as NULL (or unknown).

────────────────────────────────────────────────────────────────────────
3) Look up the most recent plan for each project
────────────────────────────────────────────────────────────────────────
For each extracted project_id, query your Control Plane database:

-------------------------------------------
SELECT p.name AS plan_name
FROM project_plan_changelogs AS ppc
JOIN plans AS p ON p.id = ppc.plan_id
WHERE ppc.project_id = '<PROJECT_ID_PLACEHOLDER>'
ORDER BY ppc.created_at DESC
LIMIT 1;
-------------------------------------------

If no record is found, you might treat the plan as "free" or "unknown."

────────────────────────────────────────────────────────────────────────
4) Classify each ticket into downtime, reliability, performance, bug, 
   feature request, or others
────────────────────────────────────────────────────────────────────────
Use simple keyword searches (in either subject or description) to determine the category:

• downtime: words like “outage”, “unable to access console”, “cannot reach GraphQL endpoint”, “production environment down”, “500 error”, “time out”  
• reliability: words like “intermittent”, “random failure”, “unreliable”, “unstable”  
• performance: words like “slow”, “latency”, “performance issue”, “high response time”  
• bug: words like “bug”, “wrong results”, “unauthorized access allowed”  
• feature request: words like “feature request”, “enhancement”, “would like to have new functionality”  
• others: everything else  

A simple approach could be a prioritized keyword search. The first matching category “wins.” If you find multiple relevant words, whichever category’s word appears first in your search logic is used.

────────────────────────────────────────────────────────────────────────
5) Sort the filtered tickets by priority
────────────────────────────────────────────────────────────────────────
From these 20 tickets, apply your sorting rules in the following order. When comparing two tickets A and B:

1. If a ticket is on the advanced plan with category “downtime” or “reliability,” it ranks higher.  
2. If a ticket is on the base plan with category “downtime” or “reliability,” it ranks higher.  
3. If a ticket is on the free plan with category “downtime,” it ranks higher.  
4. Then compare categories by this order (descending in importance):  
   downtime → reliability → performance → bug → feature request → others  
5. If still tied, compare created_at (older ticket = higher priority).

────────────────────────────────────────────────────────────────────────
6) Pick the top 5 and return them in the requested format
────────────────────────────────────────────────────────────────────────
Finally, select only the top 5 tickets after applying the above sort logic, and return them in the format:

<tickets>
TICKET_ID_1
TICKET_ID_2
TICKET_ID_3
TICKET_ID_4
TICKET_ID_5
</tickets>

────────────────────────────────────────────────────────────────────────
Example End-to-End (Fictitious Data)
────────────────────────────────────────────────────────────────────────
Below is an illustrative example of how your final result might look once the above queries and sorting logic are applied. The ticket IDs and categories are purely hypothetical:

-- 1) Suppose you retrieved these 6 open tickets (just an example):
 id   | subject                                   | description                                                                                 | created_at                     
------+-------------------------------------------+---------------------------------------------------------------------------------------------+-------------------------------
 101  | Production is completely down             | We are seeing a 500 error repeatedly. Project ID: 11111111-2222-3333-4444-555555555555       | 2023-09-11 15:23:10
 102  | Slow queries in production                | Queries are much slower than normal. PId: aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee               | 2023-09-12 07:10:45
 103  | Bug in permissions                        | We found a bug. project=12345678-1234-1234-1234-1234567890ab                                 | 2023-09-12 08:43:00
 104  | Feature request for extra action settings | I'd love an enhancement to batch actions.                                                   | 2023-09-13 11:03:29
 105  | Random 503 errors observed               | We get random 503 errors in prod. Project UUID: 22222222-3333-4444-5555-666666666666         | 2023-09-13 12:01:09
 106  | Another user question                     | Non-urgent question about usage.                                                            | 2023-09-14 09:15:00

-- 2) Extract project IDs from description:
 Ticket 101 => project_id = 11111111-2222-3333-4444-555555555555
 Ticket 102 => project_id = aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
 Ticket 103 => project_id = 12345678-1234-1234-1234-1234567890ab
 Ticket 104 => project_id = NULL (no mention)
 Ticket 105 => project_id = 22222222-3333-4444-5555-666666666666
 Ticket 106 => project_id = NULL (no mention)

-- 3) Check plan for each project (fictitious final plan):
 11111111-2222-3333-4444-555555555555 => advanced
 aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee => base
 12345678-1234-1234-1234-1234567890ab => advanced
 22222222-3333-4444-5555-666666666666 => free
 NULL => unknown

-- 4) Classify tickets:
 101 => mentions “500 error… production completely down” => downtime
 102 => “Slow queries… slower than normal” => performance
 103 => “bug in permissions” => bug
 104 => “feature request” => feature request
 105 => “random 503 errors in prod” => reliability
 106 => unclear, no typical keywords => others

-- 5) Sort by priority:
   • Ticket 101: plan=advanced, category=downtime
   • Ticket 105: plan=free, category=reliability
   • Ticket 105 vs 102 => 105 (reliability on free plan) only outranks 102’s performance if the “downtime on free plan” rule existed, but we only have a reliability vs performance with plan consideration. According to the sorting rules: 
        - advanced downtime or reliability is top
        - base downtime or reliability is next
        - free downtime next
        - then downtime > reliability > performance > bug > feature request > others
     So let’s systematically compare:

   Ticket 101 (adv + downtime) outranks everything else.  
   Among the rest: 
     - Ticket 105 (free + reliability)
     - Ticket 102 (performance)
     - Ticket 103 (bug)
     - Ticket 104 (feature request)
     - Ticket 106 (others)
   Compare categories in order → reliability outranks performance, bug, feature request, others. So ticket 105 is next. 
   Then 102 (performance) outranks 103 (bug), 104 (feature request), 106 (others).  
   Then 103 (bug) outranks 104 (feature request) which outranks 106 (others).
   Therefore final sorted order of these 6 is:  
     1) 101  (adv + downtime)  
     2) 105  (free + reliability)  
     3) 102  (any plan + performance)  
     4) 103  (bug)  
     5) 104  (feature request)  
     6) 106  (others)

-- 6) Pick top 5 and return:
<tickets>
101
105
102
103
104
</tickets>

That is the final output (the top 5 tickets in descending priority).

────────────────────────────────────────────────────────────────────────
Final Notes
────────────────────────────────────────────────────────────────────────
• In your actual workflow, you would gather the 20 open tickets, parse each description for the UUID, look up the plan name, do the category classification, apply the priority rules, and then return the final top 5 ticket IDs in the requested format.  
• If some tickets have no identifiable project ID, you could consider them as “unknown” plan or treat them as “free” (depending on your business rules).  
• Be mindful of subtle edge cases (e.g., tickets referencing multiple possible UUIDs, multiple plan changes for a project, or multiple keywords that could match different categories).  

Once you have implemented this logic with real data, you should get a final, stable list of the 5 highest-priority tickets in:

<tickets>
TICKET_ID_1
TICKET_ID_2
TICKET_ID_3
TICKET_ID_4
TICKET_ID_5
</tickets>