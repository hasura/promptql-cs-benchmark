Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 30 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is an outline of how to retrieve the last 30 “open” tickets, extract the project ID from each ticket description, determine the project’s latest plan, classify each ticket, then sort and return the top 5 ticket IDs according to the specified priority rules. Because the underlying data may vary, the example final output below is illustrative.

--------------------------------------------------------------------------------
1) Fetch the last 30 open tickets from the support tickets database
--------------------------------------------------------------------------------
Use a query similar to:

SELECT
  id,
  description,
  created_at
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 30;

--------------------------------------------------------------------------------
2) Extract the project ID from each ticket description
--------------------------------------------------------------------------------
Project IDs are UUIDs, so you can look for any substring that matches the UUID pattern:

[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}

In pseudocode:

for each ticket in results:
  match = regex(description, pattern="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}")
  project_id = match if found else null

--------------------------------------------------------------------------------
3) Look up that project’s latest plan in the control plane
--------------------------------------------------------------------------------
With the extracted project_id, you can look up the latest plan via the project_plan_changelogs and plans tables:

SELECT pl.name AS plan_name
FROM project_plan_changelogs pc
JOIN plans pl ON pc.plan_id = pl.id
WHERE pc.project_id = '<EXTRACTED_PROJECT_ID>'
ORDER BY pc.created_at DESC
LIMIT 1;

--------------------------------------------------------------------------------
4) Classify each ticket into one of the categories
--------------------------------------------------------------------------------
Using the ticket’s description (or subject), look for relevant keywords/phrases to decide among:
• downtime
• reliability
• performance
• bug
• feature request
• others

Classification examples:
• Contains “widespread service disruption,” “cannot access console,” “500 errors” → downtime
• Mentions “occasional request failures,” “random timeouts” → reliability
• Mentions “very slow response times,” “high latency,” “performance issue” → performance
• Mentions “unexpected or incorrect functionality,” “returned wrong results” → bug
• Mentions “would like a new feature,” “enhancement request,” “feature request” → feature request
• Everything else → others

--------------------------------------------------------------------------------
5) Sort the 30 tickets and pick the top 5 using the custom priority rules
--------------------------------------------------------------------------------
Priority rules, in order:
  a) If a ticket is on the "advanced" plan and has category = 'downtime' or 'reliability', it outranks all others.
  b) Then sort by ticket category, using this order (highest to lowest):
     1. downtime
     2. reliability
     3. performance
     4. bug
     5. feature request
     6. others
  c) If there’s still a tie, pick the older ticket first (compare created_at ascending).

--------------------------------------------------------------------------------
6) Return the top 5 ticket IDs
--------------------------------------------------------------------------------
After applying the above rules, take the first 5 tickets from your sorted list and return them as follows:

<tickets>
TICKET_ID_1
TICKET_ID_2
TICKET_ID_3
TICKET_ID_4
TICKET_ID_5
</tickets>

--------------------------------------------------------------------------------
Example of final output (assuming the IDs below ended up on top after sorting)
--------------------------------------------------------------------------------

<tickets>
1012
1007
994
1001
987
</tickets>

--------------------------------------------------------------------------------
Complete Summary
--------------------------------------------------------------------------------
1. SELECT last 30 open tickets (ordered by newest first).
2. For each, parse description to extract the UUID project_id (if present).
3. Query the control plane to get the project’s most recent plan.
4. Classify the ticket by content.
5. Sort using the custom rules (advanced downtime/reliability first, then category, then older is higher priority).
6. Return the top 5 in the requested <tickets>…</tickets> format.