Query:
Give me a sorted list of top 5 support tickets which I should prioritize amongst the last 5 open tickets (i.e., status = 'open').

For each ticket do the following:
- intelligently extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the time the ticket was created at
- classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures and service instability, affecting system reliability and user experience. 

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

Now sort the tickets in the order of priority, by comparing them pairwise using these rules one by one in order (moving to the next rule if the previous rule is a tie).
- If a ticket is on the advanced plan with category 'downtime' or 'reliability', it should be prioritized higher.
- Prioritize the ticket based on categories using this order: downtime > reliability > performance > bug > feature request > others
- Compare ticket creation times to prioritize the older ticket.

Return the list of ticket IDs inside the tags <tickets> </tickets> with a single ticket ID in a single line
Example:
<tickets>
123
987
</tickets>

Response:
Below is a step-by-step outline of how to determine the priority ordering of the "last 5 open tickets" and produce the final list of ticket IDs. Because this involves multiple steps (extracting data, performing classification, and sorting), you can adapt this outline as needed in your code.

────────────────────────────────────────────────────────────────────────
1) Retrieve the last 5 open tickets
────────────────────────────────────────────────────────────────────────
Use the Support Tickets database to find the 5 most recently created tickets that are still open:

SELECT 
  id, 
  subject, 
  description, 
  created_at
FROM support_ticket
WHERE status = 'open'
ORDER BY created_at DESC
LIMIT 5;

You will get up to 5 tickets, each with (id, subject, description, created_at).

────────────────────────────────────────────────────────────────────────
2) Extract project ID from the ticket description
────────────────────────────────────────────────────────────────────────
Because project IDs are UUIDs, you can parse the description using a UUID regex (in your application code). For example, in many programming languages a suitable pattern for extracting the first valid UUID is:

([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})

Pseudocode example of how you might do this for each ticket row:
--------------------------------------------------------------------------------
// Pseudocode
uuid_regex = "([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})"
project_id = extract_first_match(ticket.description, uuid_regex)
--------------------------------------------------------------------------------

If no UUID is found, keep project_id as NULL (or similar).

────────────────────────────────────────────────────────────────────────
3) Get the project’s most recent plan
────────────────────────────────────────────────────────────────────────
For each extracted project_id (call it :pid), retrieve the most recent plan from the Control Plane database. You can do this by joining project_plan_changelogs to plans on plan_id and ordering by created_at DESC:

SELECT 
    ppc.project_id,
    p.name AS plan_name
FROM project_plan_changelogs ppc
JOIN plans p ON ppc.plan_id = p.id
WHERE ppc.project_id = :pid
ORDER BY ppc.created_at DESC
LIMIT 1;

Store plan_name for each ticket’s project. If no row is found, consider it unknown or treat as a default (e.g., "Free").

────────────────────────────────────────────────────────────────────────
4) Classify each ticket into a category
────────────────────────────────────────────────────────────────────────
Use the prepared classification rules, examining the ticket’s subject and description. This can be done in code, for instance checking presence of key words or phrases, or by applying more sophisticated text analysis. The categories are:

1) Downtime
2) Reliability
3) Performance
4) Bug
5) Feature request
6) Others

Adhering to the definitions provided (e.g., “downtime” → service disruptions, 500 errors, timeouts; “performance” → query latency, slow response times; etc.).

────────────────────────────────────────────────────────────────────────
5) Sort the 5 tickets by priority
────────────────────────────────────────────────────────────────────────
Now apply the priority rules pairwise in the following order, stopping at the first rule that breaks a tie:

a) If a ticket is on the “advanced” plan and its category is “downtime” or “reliability,” that ticket is prioritized higher.  
b) Otherwise, compare by the category according to this order:  
   downtime > reliability > performance > bug > feature request > others  
c) If there is still a tie, compare by the older creation time – older ticket gets higher priority.

Pseudocode for sorting logic (assume you have an array of Ticket objects):

--------------------------------------------------------------------------------
// Pseudocode
function ticketPriorityValue(ticket) {
  // a) advanced + (downtime|reliability) => highest "modifier"
  let baseValue;
  switch (ticket.category) {
    case "downtime":          baseValue = 6; break;
    case "reliability":       baseValue = 5; break;
    case "performance":       baseValue = 4; break;
    case "bug":               baseValue = 3; break;
    case "feature request":   baseValue = 2; break;
    default:                  baseValue = 1; // others
  }

  // If advanced plan and downtime/reliability, add a bonus to move it up
  // e.g., add 10 to push it above everything not matching that condition.
  if (ticket.plan_name == "advanced" &&
      (ticket.category == "downtime" || ticket.category == "reliability")) {
    baseValue += 10;
  }

  return baseValue;
}

// Then sort the array by (descending ticketPriorityValue), 
//    then by ascending created_at if tie in priority value.

tickets.sort((a, b) => {
  // compare by priority value
  let diff = ticketPriorityValue(b) - ticketPriorityValue(a);
  if (diff != 0) return diff;

  // if same priority value, older ticket first => ascending created_at
  // i.e., compare a.created_at - b.created_at
  return a.created_at - b.created_at;
});
--------------------------------------------------------------------------------

────────────────────────────────────────────────────────────────────────
6) Return the final list of ticket IDs
────────────────────────────────────────────────────────────────────────
After sorting, output the ticket IDs in the required format. For example, assume your final array of ticket objects is in the sorted order you computed. Return them as:

<tickets>
TICKET_ID_1
TICKET_ID_2
TICKET_ID_3
TICKET_ID_4
TICKET_ID_5
</tickets>

Where TICKET_ID_1 is the highest priority ticket, TICKET_ID_2 is next, and so on.

────────────────────────────────────────────────────────────────────────
Example Final Output
────────────────────────────────────────────────────────────────────────
<tickets>
123
456
890
234
678
</tickets>

(This is merely an example. Actual IDs come from your data.)

────────────────────────────────────────────────────────────────────────
Summary
────────────────────────────────────────────────────────────────────────
By following the above steps, you can:

• Fetch the last 5 open tickets.  
• Extract each ticket’s project_id from description.  
• Look up that project’s most recent plan.  
• Classify the ticket according to the definitions provided (downtime, reliability, etc.).  
• Output them sorted using the special prioritized rules.  

The final answer from your code should be the list of ticket IDs enclosed by <tickets></tickets>, one per line, in the correct priority order.