[
  {
    "timestamp": "2025-01-29T13:15:45.409981",
    "response": {
      "id": "chatcmpl-Aux35BY0hDpilImeoUZ0fJkb52GX0",
      "choices": [
        {
          "finish_reason": "stop",
          "index": 0,
          "logprobs": null,
          "message": {
            "content": "Below is one way you could retrieve and prioritize the top 5 support tickets from among the most recent 10 open tickets, according to your specified rules. Because the classification, plan retrieval, and sorting have multiple steps (and cannot be done strictly in a single SQL query), the outline below shows how you might approach the task programmatically. The final output you would produce is illustrated at the end.\n\n--------------------------------------------------------------------------------\n1) Retrieve the 10 most recent open tickets\n\nUse the support tickets database. For example:\n\nSELECT \n  t.id,\n  t.description,\n  t.created_at\nFROM support_ticket AS t\nWHERE t.status = 'open'\nORDER BY t.created_at DESC\nLIMIT 10;\n\nThis will give you the latest 10 open tickets by creation time.\n\n--------------------------------------------------------------------------------\n2) Extract the project ID from each ticket\u2019s description\n\n\u2022 Project IDs are UUIDs. A typical pattern is:\n  [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\n  \n\u2022 For each ticket row fetched in Step 1, run a regex over description to find the UUID:\n  For example, in many programming languages (pseudo-code):\n  \n  match = regex_find(description, /[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/)\n  projectId = match if found\n  \nIf no project ID is found, you might consider that ticket as having no associated project (e.g., plan = unknown).\n\n--------------------------------------------------------------------------------\n3) Find the most recent plan for each project\n\nNow, for each extracted projectId, query the control plane database to retrieve the most recent plan. A typical approach:\n\n-- Find the latest plan for the project\nSELECT \n  pc.plan_id\nFROM project_plan_changelogs AS pc\nWHERE pc.project_id = :extracted_project_id\nORDER BY pc.created_at DESC\nLIMIT 1;\n\nThen, map that plan_id to the actual plan name:\n\nSELECT \n  p.name\nFROM plans AS p\nWHERE p.id = :plan_id;\n\nLet\u2019s call that name the \u201cplanName\u201d for the ticket.\n\n--------------------------------------------------------------------------------\n4) Classify each ticket\n\nInspect each ticket\u2019s subject or description to assign a single category from:\n\u2022 downtime\n\u2022 reliability\n\u2022 performance\n\u2022 bug\n\u2022 feature request\n\u2022 others\n\nFor example, you could search for particular keywords or patterns in the ticket description:\n\n\u2022 \"widespread service disruptions\", \"500 errors\", \"cannot access console\" => downtime  \n\u2022 \"intermittent connectivity\", \"random request failures\" => reliability  \n\u2022 \"performance issues\", \"high latency\" => performance  \n\u2022 \"reporting a bug\", \"unexpected behavior\", \"incorrect results\" => bug  \n\u2022 \"would love if Hasura could do X\", \"feature request\" => feature request  \n\u2022 otherwise => others  \n\n--------------------------------------------------------------------------------\n5) Sort the 10 tickets to find the top 5\n\nApply your sorting rules pairwise in this order:\n\n1. If a ticket is on the ADVANCED plan with category = 'downtime' OR 'reliability', it is prioritized higher.\n2. Otherwise, prioritize by category in this order:\n   downtime > reliability > performance > bug > feature request > others.\n3. For any tie, the older ticket (earlier created_at) is prioritized higher.\n\nAfter sorting by these rules, take the first 5 tickets.\n\n--------------------------------------------------------------------------------\n6) Return the final sorted ticket IDs in the requested format\n\n<tickets>\nTICKET_ID_1\nTICKET_ID_2\nTICKET_ID_3\nTICKET_ID_4\nTICKET_ID_5\n</tickets>\n\n--------------------------------------------------------------------------------\nExample (Hypothetical Data)\n\nAssume after running your queries, you extract and classify these 10 open tickets (showing only partial details):\n\n1) id = 801\n   project_id = 1a651e3a-d824-4d53-a1fc-7c608a093ca9\n   planName = 'advanced'\n   created_at = 2023-09-15 12:05:00\n   category = 'downtime'\n\n2) id = 802\n   project_id = 2b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'advanced'\n   created_at = 2023-09-15 12:10:00\n   category = 'reliability'\n\n3) id = 803\n   project_id = 3b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'standard'\n   created_at = 2023-09-15 12:12:00\n   category = 'reliability'\n\n4) id = 804\n   project_id = 4b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'team'\n   created_at = 2023-09-17 09:00:00\n   category = 'feature request'\n\n5) id = 805\n   project_id = 5b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'advanced'\n   created_at = 2023-09-18 08:00:00\n   category = 'bug'\n\n6) id = 806\n   project_id = 6b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'standard'\n   created_at = 2023-09-18 08:10:00\n   category = 'performance'\n\n7) id = 807\n   project_id = 7b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'standard'\n   created_at = 2023-09-18 09:00:00\n   category = 'performance'\n\n8) id = 808\n   project_id = 8b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'team'\n   created_at = 2023-09-19 10:00:00\n   category = 'bug'\n\n9) id = 809\n   project_id = 9b650e3a-d824-4d53-a1fc-7c608a093cb9\n   planName = 'standard'\n   created_at = 2023-09-20 08:00:00\n   category = 'downtime'       -- Rare but possible\n\n10) id = 810\n    project_id = abc50e3a-d824-4d53-a1fc-7c608a093cb9\n    planName = 'standard'\n    created_at = 2023-09-21 11:00:00\n    category = 'others'\n\nSorting under the rules:\n\n1) Advanced plan & (downtime or reliability) come first:\n   - #801 (advanced, downtime)  \n   - #802 (advanced, reliability)\n\n2) Next by category order (downtime > reliability > performance > bug > feature request > others):\n   Among remaining tickets, #809 has downtime but plan standard. \n   Then #803 is reliability (standard), #806 and #807 are performance, #805 and #808 are bugs, #804 is feature request, #810 is others.\n\n3) For ties in category, pick the older ticket first. (Illustrated below by comparing created_at.)\n\nHence, final priority might be:\n1) Ticket #801 (advanced, downtime)\n2) Ticket #802 (advanced, reliability)\n3) Ticket #809 (standard, downtime)\n4) Ticket #803 (standard, reliability)\n5) Ticket #806 (standard, performance) \n   -- (806 is older than 807, so #806 over #807)\n\n\u2026and so on if we needed all 10. Top 5 would be #801, #802, #809, #803, #806.\n\nYour final output:\n\n<tickets>\n801\n802\n809\n803\n806\n</tickets>\n\n--------------------------------------------------------------------------------\nSummary\n\nBy combining the steps shown (fetch last 10 open tickets, parse project UUID, retrieve plan, classify the issue, then apply your custom priority rules), you can generate the top 5 tickets that should be addressed first, listing them in ascending order of their priority rank as requested.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
          }
        }
      ],
      "created": 1738136715,
      "model": "o1-2024-12-17",
      "object": "chat.completion",
      "service_tier": "default",
      "system_fingerprint": "fp_d91c966719",
      "usage": {
        "completion_tokens": 4090,
        "prompt_tokens": 1010,
        "total_tokens": 5100,
        "completion_tokens_details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 2240,
          "rejected_prediction_tokens": 0
        },
        "prompt_tokens_details": {
          "audio_tokens": 0,
          "cached_tokens": 0
        }
      }
    }
  }
]