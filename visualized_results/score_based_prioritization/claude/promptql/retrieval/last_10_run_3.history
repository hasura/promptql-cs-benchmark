[
  {
    "user_message": {
      "text": "Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. \n\nFor each ticket do the following:\n- get the description of the ticket\n- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs\n- get the plan the project is most recently on\n- get the total amount of revenue generated by the project (include invoice items of all types)\n- get the email of the user creating the ticket\n- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)\n- get the created at time of the ticket\n- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.\n\nCategory descriptions for AI Classification instructions:\n\n1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.\n\n2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.\n\n3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. \n\n4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  \n\n5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. \n\n6. Others: Any other type of ticket which does not fit the above categories\n\n- Then sort the tickets in order of priority using the following scoring:\n\n1. Category Weight (0-25 points):\n- Downtime: 25 points\n- Reliability: 20 points\n- Performance: 15 points\n- Bug: 10 points\n- Feature Request: 5 points\n- Others: 0 points\n\n2. Plan Weight (0-15 points):\n- advanced: 15 points\n- base: 10 points\n- free: 0 points\n\n3. Revenue Impact (0-40 points total):\n- Project Revenue: Up to 20 points (scaled relative to highest project revenue)\n- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)\n\n4. Age (0-20 points):\nLinear scale where:\n- Newest ticket = 20 points\n- Oldest ticket = 0 points\n- Other tickets scaled linearly between these points\n\n- Respond with an artifact with identifier \"prioritized_tickets\" containing sorted list of ticket IDs in the following format:\n[\n    {\n      \"ticket_id\": 1,\n    },\n    ...\n]\n"
    },
    "assistant_actions": [
      {
        "message": "I'll help you analyze and prioritize the support tickets.",
        "plan": "1. Get the last 10 open support tickets with their details, descriptions, and requester information\n2. For each ticket:\n   - Extract project ID from description using AI\n   - Get the most recent plan for each project\n   - Calculate project revenue from invoice items\n   - Get requester email and calculate their total revenue across all projects\n   - Classify tickets into categories using AI\n3. Calculate priority scores based on the given criteria\n4. Sort tickets by priority score and create the final artifact\n\nNote: All revenue calculations will be in the project's currency (assumed USD)",
        "code": "import datetime\nfrom functools import cmp_to_key\n\n# Get last 10 open tickets with details\nsql = \"\"\"\nSELECT \n    t.id as ticket_id,\n    t.subject,\n    t.description,\n    t.created_at,\n    t.requester_id,\n    u.email as requester_email\nFROM app.support_ticket t\nJOIN app.support_user u ON t.requester_id = u.id\nWHERE t.status = 'open'\nORDER BY t.created_at DESC\nLIMIT 10\n\"\"\"\ntickets = executor.run_sql(sql)\n\n# Extract project IDs from descriptions\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"project_id\": {\n            \"type\": \"string\",\n            \"description\": \"UUID of the project mentioned in the ticket\"\n        }\n    }\n}\nproject_ids = executor.extract(\n    json_schema=json_schema,\n    instructions=\"Extract the project ID (UUID) from the support ticket description. The project ID should be in UUID format. If multiple UUIDs are found, pick the one most likely to be the project ID based on context.\",\n    inputs=[ticket['description'] for ticket in tickets]\n)\n\n# Get most recent plan for each project\nproject_plans = {}\nfor extracted in project_ids:\n    project_id = extracted.get('project_id')\n    if not project_id:\n        continue\n        \n    sql = f\"\"\"\n    SELECT p.name as plan_name\n    FROM app.project_plan_changelogs c\n    JOIN app.plans p ON c.plan_id = p.id\n    WHERE c.project_id = '{project_id}'\n    ORDER BY c.created_at DESC\n    LIMIT 1\n    \"\"\"\n    plans = executor.run_sql(sql)\n    if plans:\n        project_plans[project_id] = plans[0]['plan_name']\n\n# Calculate revenue per project\nproject_revenues = {}\nfor extracted in project_ids:\n    project_id = extracted.get('project_id')\n    if not project_id:\n        continue\n        \n    sql = f\"\"\"\n    SELECT SUM(amount) as total_revenue\n    FROM app.invoice_item\n    WHERE project_id = '{project_id}'\n    \"\"\"\n    revenues = executor.run_sql(sql)\n    if revenues and revenues[0]['total_revenue']:\n        project_revenues[project_id] = float(revenues[0]['total_revenue'])\n\n# Calculate total revenue per user\nuser_revenues = {}\nfor ticket in tickets:\n    email = ticket['requester_email']\n    if email in user_revenues:\n        continue\n        \n    sql = f\"\"\"\n    WITH user_projects AS (\n        SELECT p.id as project_id\n        FROM app.users u\n        JOIN app.projects p ON u.id = p.owner_id\n        WHERE u.email = '{email}'\n    )\n    SELECT SUM(amount) as total_revenue\n    FROM user_projects up\n    JOIN app.invoice_item i ON up.project_id = i.project_id\n    \"\"\"\n    revenues = executor.run_sql(sql)\n    if revenues and revenues[0]['total_revenue']:\n        user_revenues[email] = float(revenues[0]['total_revenue'])\n\n# Classify tickets\nclassifications = executor.classify(\n    instructions=\"\"\"\n    Classify support tickets into the following categories based on their description:\n    \n    1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.\n\n    2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.\n\n    3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. \n\n    4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  \n\n    5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. \n\n    6. Others: Any other type of ticket which does not fit the above categories\n    \"\"\",\n    categories=['downtime', 'reliability', 'performance', 'bug', 'feature request', 'others'],\n    allow_multiple=False,\n    inputs=[f\"{ticket['subject']}\\n{ticket['description']}\" for ticket in tickets]\n)\n\n# Calculate priority scores\ndef get_category_score(category):\n    return {\n        'downtime': 25,\n        'reliability': 20,\n        'performance': 15,\n        'bug': 10,\n        'feature request': 5,\n        'others': 0\n    }.get(category, 0)\n\ndef get_plan_score(plan):\n    return {\n        'advanced': 15,\n        'base': 10,\n        'free': 0\n    }.get(plan, 0)\n\n# Get min/max timestamps for age calculation\ncreated_ats = [datetime.datetime.fromisoformat(t['created_at']) for t in tickets]\nnewest_ticket = max(created_ats)\noldest_ticket = min(created_ats)\ntime_range = (newest_ticket - oldest_ticket).total_seconds()\n\n# Get max revenues for scaling\nmax_project_revenue = max(project_revenues.values()) if project_revenues else 1\nmax_user_revenue = max(user_revenues.values()) if user_revenues else 1\n\nticket_scores = []\nfor i, ticket in enumerate(tickets):\n    project_id = project_ids[i].get('project_id')\n    created_at = datetime.datetime.fromisoformat(ticket['created_at'])\n    \n    # Category score\n    category_score = get_category_score(classifications[i])\n    \n    # Plan score\n    plan_score = get_plan_score(project_plans.get(project_id, 'free'))\n    \n    # Revenue scores\n    project_revenue = project_revenues.get(project_id, 0)\n    project_revenue_score = (project_revenue / max_project_revenue) * 20\n    \n    user_revenue = user_revenues.get(ticket['requester_email'], 0)\n    user_revenue_score = (user_revenue / max_user_revenue) * 20\n    \n    # Age score\n    if time_range == 0:\n        age_score = 20\n    else:\n        age_factor = (created_at - oldest_ticket).total_seconds() / time_range\n        age_score = age_factor * 20\n    \n    total_score = category_score + plan_score + project_revenue_score + user_revenue_score + age_score\n    \n    ticket_scores.append({\n        'ticket_id': ticket['ticket_id'],\n        'score': total_score\n    })\n\n# Sort by score descending\nsorted_tickets = sorted(ticket_scores, key=lambda x: x['score'], reverse=True)\n\n# Create final artifact with just the IDs in sorted order\nfinal_tickets = [{'ticket_id': t['ticket_id']} for t in sorted_tickets]\n\nexecutor.store_artifact(\n    'prioritized_tickets',\n    'Prioritized Support Tickets',\n    'table',\n    final_tickets\n)",
        "code_output": "SQL statement returned 10 rows.\nExtracted from 10 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 10 items\nStored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Support Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 287}]\n",
        "code_error": null
      },
      {
        "message": "Here are the support tickets sorted by priority based on the category, plan type, revenue impact, and age:\n<artifact identifier='prioritized_tickets' warning='I cannot see the full data so I must not make up observations' />\n\nEach ticket's priority was calculated using:\n- Category weight (up to 25 points): Downtime issues got highest priority (25), followed by reliability (20), performance (15), bugs (10), feature requests (5)\n- Plan type (up to 15 points): Advanced plan projects got 15 points, base plan got 10 points\n- Revenue impact (up to 40 points): Split between project revenue (20) and total user revenue (20), scaled relative to highest values\n- Ticket age (up to 20 points): Newer tickets got higher priority, scaled linearly",
        "plan": null,
        "code": null,
        "code_output": null,
        "code_error": null
      }
    ],
    "modified_artifacts": [
      {
        "identifier": "prioritized_tickets",
        "title": "Prioritized Support Tickets",
        "artifact_type": "table",
        "data": [
          {
            "ticket_id": 143
          },
          {
            "ticket_id": 287
          },
          {
            "ticket_id": 286
          },
          {
            "ticket_id": 169
          },
          {
            "ticket_id": 166
          },
          {
            "ticket_id": 139
          },
          {
            "ticket_id": 288
          },
          {
            "ticket_id": 209
          },
          {
            "ticket_id": 251
          },
          {
            "ticket_id": 289
          }
        ]
      }
    ]
  }
]