[
  {
    "user_message": {
      "text": "Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. \n\nFor each ticket do the following:\n- get the description of the ticket\n- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs\n- get the plan the project is most recently on\n- get the total amount of revenue generated by the project (include invoice items of all types)\n- get the email of the user creating the ticket\n- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)\n- get the created at time of the ticket\n- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.\n\nCategory descriptions for AI Classification instructions:\n\n1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.\n\n2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.\n\n3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. \n\n4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  \n\n5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. \n\n6. Others: Any other type of ticket which does not fit the above categories\n\n- Then sort the tickets in order of priority using the following scoring:\n\n1. Category Weight (0-25 points):\n- Downtime: 25 points\n- Reliability: 20 points\n- Performance: 15 points\n- Bug: 10 points\n- Feature Request: 5 points\n- Others: 0 points\n\n2. Plan Weight (0-15 points):\n- advanced: 15 points\n- base: 10 points\n- free: 0 points\n\n3. Revenue Impact (0-40 points total):\n- Project Revenue: Up to 20 points (scaled relative to highest project revenue)\n- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)\n\n4. Age (0-20 points):\nLinear scale where:\n- Newest ticket = 20 points\n- Oldest ticket = 0 points\n- Other tickets scaled linearly between these points\n\n- Respond with an artifact with identifier \"prioritized_tickets\" containing sorted list of ticket IDs in the following format:\n[\n    {\n      \"ticket_id\": 1,\n    },\n    ...\n]\n"
    },
    "assistant_actions": [
      {
        "message": "I'll help you analyze and prioritize the support tickets.",
        "plan": "1. Get the last 10 open support tickets with their details, descriptions, and requester information\n2. For each ticket:\n   - Extract project ID from description using AI\n   - Get the most recent plan for each project\n   - Calculate project revenue from invoice items\n   - Get requester email and calculate their total revenue across all projects\n   - Classify ticket type using AI\n3. Calculate priority scores based on the given criteria\n4. Sort tickets by priority score and create the final artifact\n\nNote: All revenue calculations will be in the project's currency (assumed USD)",
        "code": "import datetime\nfrom functools import cmp_to_key\n\n# Get last 10 open tickets with details\nsql = \"\"\"\nSELECT \n    t.id as ticket_id,\n    t.subject,\n    t.description,\n    t.created_at,\n    u.email as requester_email\nFROM app.support_ticket t\nJOIN app.support_user u ON t.requester_id = u.id\nWHERE t.status = 'open'\nORDER BY t.created_at DESC\nLIMIT 10\n\"\"\"\ntickets = executor.run_sql(sql)\n\n# Extract project IDs using AI\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"project_id\": {\n            \"type\": \"string\",\n            \"description\": \"UUID of the project mentioned in the ticket\"\n        }\n    }\n}\nproject_ids = executor.extract(\n    json_schema=json_schema,\n    instructions=\"Extract the project ID (UUID) from the support ticket description. The project ID should be in UUID format. If no valid UUID is found, return null for project_id.\",\n    inputs=[ticket['description'] for ticket in tickets]\n)\n\n# Classify tickets\nclassifications = executor.classify(\n    instructions=\"\"\"\n    Classify support tickets into the following categories based on their subject and description:\n    \n    1. Downtime: Widespread service disruptions, inability to access services, production outages, API failures\n    2. Reliability: Intermittent connectivity issues, random failures, service instability\n    3. Performance: Slow response times, increased latency, slow processing\n    4. Bug: Software behavior issues, incorrect functionality\n    5. Feature request: Requests for new functionality or enhancements\n    6. Others: Any other type of ticket\n    \"\"\",\n    categories=['downtime', 'reliability', 'performance', 'bug', 'feature request', 'others'],\n    allow_multiple=False,\n    inputs=[f\"Subject: {t['subject']}\\nDescription: {t['description']}\" for t in tickets]\n)\n\n# Get project details and revenue\nproject_details = {}\nuser_total_revenue = {}\n\nfor ticket, extracted in zip(tickets, project_ids):\n    project_id = extracted.get('project_id')\n    if not project_id:\n        continue\n        \n    # Get most recent plan\n    sql = f\"\"\"\n    SELECT p.name as plan_name\n    FROM app.project_plan_changelogs c\n    JOIN app.plans p ON c.plan_id = p.id\n    WHERE c.project_id = '{project_id}'\n    ORDER BY c.created_at DESC\n    LIMIT 1\n    \"\"\"\n    plan_results = executor.run_sql(sql)\n    plan_name = plan_results[0]['plan_name'] if plan_results else None\n    \n    # Get project revenue\n    sql = f\"\"\"\n    SELECT SUM(amount) as total_amount\n    FROM app.invoice_item\n    WHERE project_id = '{project_id}'\n    \"\"\"\n    revenue_results = executor.run_sql(sql)\n    project_revenue = revenue_results[0]['total_amount'] if revenue_results else 0\n    \n    project_details[ticket['ticket_id']] = {\n        'plan': plan_name,\n        'revenue': project_revenue or 0\n    }\n    \n    # Calculate user's total revenue across all projects\n    if ticket['requester_email'] not in user_total_revenue:\n        sql = f\"\"\"\n        WITH user_projects AS (\n            SELECT p.id as project_id\n            FROM app.users u\n            JOIN app.projects p ON u.id = p.owner_id\n            WHERE u.email = '{ticket['requester_email']}'\n        )\n        SELECT SUM(amount) as total_amount\n        FROM app.invoice_item i\n        WHERE i.project_id IN (SELECT project_id FROM user_projects)\n        \"\"\"\n        user_revenue_results = executor.run_sql(sql)\n        user_total_revenue[ticket['requester_email']] = user_revenue_results[0]['total_amount'] if user_revenue_results else 0\n\n# Calculate priority scores\nnow = datetime.datetime.now()\noldest_ticket = min(datetime.datetime.fromisoformat(t['created_at']) for t in tickets)\nnewest_ticket = max(datetime.datetime.fromisoformat(t['created_at']) for t in tickets)\ntime_range = (newest_ticket - oldest_ticket).total_seconds()\n\n# Find max revenues for scaling\nmax_project_revenue = max((details['revenue'] for details in project_details.values()), default=0)\nmax_user_revenue = max(user_total_revenue.values(), default=0)\n\ndef calculate_score(ticket, classification):\n    ticket_id = ticket['ticket_id']\n    \n    # Category weight\n    category_scores = {\n        'downtime': 25,\n        'reliability': 20,\n        'performance': 15,\n        'bug': 10,\n        'feature request': 5,\n        'others': 0\n    }\n    category_score = category_scores[classification]\n    \n    # Plan weight\n    plan_scores = {\n        'advanced': 15,\n        'base': 10,\n        None: 0  # for unknown plans\n    }\n    plan_score = plan_scores.get(project_details.get(ticket_id, {}).get('plan'), 0)\n    \n    # Revenue impact\n    project_revenue = project_details.get(ticket_id, {}).get('revenue', 0)\n    user_revenue = user_total_revenue.get(ticket['requester_email'], 0)\n    \n    project_revenue_score = (project_revenue / max_project_revenue * 20) if max_project_revenue > 0 else 0\n    user_revenue_score = (user_revenue / max_user_revenue * 20) if max_user_revenue > 0 else 0\n    \n    # Age score\n    ticket_time = datetime.datetime.fromisoformat(ticket['created_at'])\n    age_factor = (ticket_time - oldest_ticket).total_seconds() / time_range if time_range > 0 else 0\n    age_score = age_factor * 20\n    \n    return category_score + plan_score + project_revenue_score + user_revenue_score + age_score\n\n# Calculate scores and sort tickets\nticket_scores = []\nfor ticket, classification in zip(tickets, classifications):\n    score = calculate_score(ticket, classification)\n    ticket_scores.append((ticket['ticket_id'], score))\n\n# Sort by score in descending order\nsorted_tickets = sorted(ticket_scores, key=lambda x: x[1], reverse=True)\n\n# Create final artifact\nprioritized_tickets = [{\"ticket_id\": ticket_id} for ticket_id, _ in sorted_tickets]\n\nexecutor.store_artifact(\n    'prioritized_tickets',\n    'Prioritized Support Tickets',\n    'table',\n    prioritized_tickets\n)",
        "code_output": "SQL statement returned 10 rows.\nExtracted from 10 items\nClassified 10 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\n",
        "code_error": "Traceback (most recent call last):\n  File \"/lib/python312.zip/_pyodide/_base.py\", line 596, in eval_code_async\n    await CodeRunner(\n  File \"/lib/python312.zip/_pyodide/_base.py\", line 410, in run_async\n    coroutine = eval(self.code, globals, locals)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<exec>\", line 112, in <module>\nTypeError: '>' not supported between instances of 'NoneType' and 'int'\n"
      },
      {
        "message": "I apologize for the error. It seems some of the revenue values are None, which caused issues in comparison. Let me fix that and handle null values properly.",
        "plan": "Same plan as before, but with better null value handling:\n1. Get the last 10 open support tickets with their details\n2. For each ticket:\n   - Extract project ID from description using AI\n   - Get the most recent plan for each project\n   - Calculate project revenue from invoice items (handle nulls)\n   - Get requester email and calculate their total revenue (handle nulls)\n   - Classify ticket type using AI\n3. Calculate priority scores with proper null handling\n4. Sort tickets by priority score and create the final artifact",
        "code": "import datetime\nfrom functools import cmp_to_key\n\n# Get last 10 open tickets with details\nsql = \"\"\"\nSELECT \n    t.id as ticket_id,\n    t.subject,\n    t.description,\n    t.created_at,\n    u.email as requester_email\nFROM app.support_ticket t\nJOIN app.support_user u ON t.requester_id = u.id\nWHERE t.status = 'open'\nORDER BY t.created_at DESC\nLIMIT 10\n\"\"\"\ntickets = executor.run_sql(sql)\n\n# Extract project IDs using AI\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"project_id\": {\n            \"type\": \"string\",\n            \"description\": \"UUID of the project mentioned in the ticket\"\n        }\n    }\n}\nproject_ids = executor.extract(\n    json_schema=json_schema,\n    instructions=\"Extract the project ID (UUID) from the support ticket description. The project ID should be in UUID format. If no valid UUID is found, return null for project_id.\",\n    inputs=[ticket['description'] for ticket in tickets]\n)\n\n# Classify tickets\nclassifications = executor.classify(\n    instructions=\"\"\"\n    Classify support tickets into the following categories based on their subject and description:\n    \n    1. Downtime: Widespread service disruptions, inability to access services, production outages, API failures\n    2. Reliability: Intermittent connectivity issues, random failures, service instability\n    3. Performance: Slow response times, increased latency, slow processing\n    4. Bug: Software behavior issues, incorrect functionality\n    5. Feature request: Requests for new functionality or enhancements\n    6. Others: Any other type of ticket\n    \"\"\",\n    categories=['downtime', 'reliability', 'performance', 'bug', 'feature request', 'others'],\n    allow_multiple=False,\n    inputs=[f\"Subject: {t['subject']}\\nDescription: {t['description']}\" for t in tickets]\n)\n\n# Get project details and revenue\nproject_details = {}\nuser_total_revenue = {}\n\nfor ticket, extracted in zip(tickets, project_ids):\n    project_id = extracted.get('project_id')\n    if not project_id:\n        project_details[ticket['ticket_id']] = {\n            'plan': None,\n            'revenue': 0\n        }\n        continue\n        \n    # Get most recent plan\n    sql = f\"\"\"\n    SELECT p.name as plan_name\n    FROM app.project_plan_changelogs c\n    JOIN app.plans p ON c.plan_id = p.id\n    WHERE c.project_id = '{project_id}'\n    ORDER BY c.created_at DESC\n    LIMIT 1\n    \"\"\"\n    plan_results = executor.run_sql(sql)\n    plan_name = plan_results[0]['plan_name'] if plan_results else None\n    \n    # Get project revenue\n    sql = f\"\"\"\n    SELECT COALESCE(SUM(amount), 0) as total_amount\n    FROM app.invoice_item\n    WHERE project_id = '{project_id}'\n    \"\"\"\n    revenue_results = executor.run_sql(sql)\n    project_revenue = float(revenue_results[0]['total_amount']) if revenue_results else 0\n    \n    project_details[ticket['ticket_id']] = {\n        'plan': plan_name,\n        'revenue': project_revenue\n    }\n    \n    # Calculate user's total revenue across all projects\n    if ticket['requester_email'] not in user_total_revenue:\n        sql = f\"\"\"\n        WITH user_projects AS (\n            SELECT p.id as project_id\n            FROM app.users u\n            JOIN app.projects p ON u.id = p.owner_id\n            WHERE u.email = '{ticket['requester_email']}'\n        )\n        SELECT COALESCE(SUM(amount), 0) as total_amount\n        FROM app.invoice_item i\n        WHERE i.project_id IN (SELECT project_id FROM user_projects)\n        \"\"\"\n        user_revenue_results = executor.run_sql(sql)\n        user_total_revenue[ticket['requester_email']] = float(user_revenue_results[0]['total_amount']) if user_revenue_results else 0\n\n# Calculate priority scores\nnow = datetime.datetime.now()\nticket_times = [datetime.datetime.fromisoformat(t['created_at']) for t in tickets]\noldest_ticket = min(ticket_times)\nnewest_ticket = max(ticket_times)\ntime_range = (newest_ticket - oldest_ticket).total_seconds()\n\n# Find max revenues for scaling\nmax_project_revenue = max((details['revenue'] for details in project_details.values()), default=1)\nmax_user_revenue = max(user_total_revenue.values(), default=1)\n\ndef calculate_score(ticket, classification):\n    ticket_id = ticket['ticket_id']\n    \n    # Category weight\n    category_scores = {\n        'downtime': 25,\n        'reliability': 20,\n        'performance': 15,\n        'bug': 10,\n        'feature request': 5,\n        'others': 0\n    }\n    category_score = category_scores[classification]\n    \n    # Plan weight\n    plan_scores = {\n        'advanced': 15,\n        'base': 10,\n        None: 0  # for unknown plans\n    }\n    plan_score = plan_scores.get(project_details.get(ticket_id, {}).get('plan'), 0)\n    \n    # Revenue impact\n    project_revenue = project_details.get(ticket_id, {}).get('revenue', 0)\n    user_revenue = user_total_revenue.get(ticket['requester_email'], 0)\n    \n    project_revenue_score = (project_revenue / max_project_revenue * 20) if max_project_revenue > 0 else 0\n    user_revenue_score = (user_revenue / max_user_revenue * 20) if max_user_revenue > 0 else 0\n    \n    # Age score\n    ticket_time = datetime.datetime.fromisoformat(ticket['created_at'])\n    age_factor = (ticket_time - oldest_ticket).total_seconds() / time_range if time_range > 0 else 0\n    age_score = age_factor * 20\n    \n    total_score = category_score + plan_score + project_revenue_score + user_revenue_score + age_score\n    \n    executor.print(f\"Ticket {ticket_id} scores: category={category_score}, plan={plan_score}, project_rev={project_revenue_score}, user_rev={user_revenue_score}, age={age_score}, total={total_score}\")\n    \n    return total_score\n\n# Calculate scores and sort tickets\nticket_scores = []\nfor ticket, classification in zip(tickets, classifications):\n    score = calculate_score(ticket, classification)\n    ticket_scores.append((ticket['ticket_id'], score))\n\n# Sort by score in descending order\nsorted_tickets = sorted(ticket_scores, key=lambda x: x[1], reverse=True)\n\n# Create final artifact\nprioritized_tickets = [{\"ticket_id\": ticket_id} for ticket_id, _ in sorted_tickets]\n\nexecutor.store_artifact(\n    'prioritized_tickets',\n    'Prioritized Support Tickets',\n    'table',\n    prioritized_tickets\n)",
        "code_output": "SQL statement returned 10 rows.\nExtracted from 10 items\nClassified 10 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nTicket 143 scores: category=25, plan=10, project_rev=0.0, user_rev=20.0, age=20.0, total=75.0\nTicket 166 scores: category=5, plan=10, project_rev=0.0, user_rev=20.0, age=16.590805206264175, total=51.59080520626418\nTicket 287 scores: category=25, plan=15, project_rev=11.571428571428573, user_rev=3.78885811018775, age=14.194257568887519, total=69.55454425050384\nTicket 288 scores: category=20, plan=0, project_rev=0.0, user_rev=6.617420744844567, age=12.661191985540905, total=39.27861273038547\nTicket 209 scores: category=25, plan=0, project_rev=0.0, user_rev=0.0, age=12.393173526913873, total=37.39317352691387\nTicket 289 scores: category=15, plan=0, project_rev=0.0, user_rev=0.0, age=11.321099692405754, total=26.321099692405753\nTicket 169 scores: category=15, plan=15, project_rev=20.0, user_rev=3.508771929824561, age=6.453884483738887, total=59.96265641356345\nTicket 286 scores: category=25, plan=15, project_rev=20.0, user_rev=3.508771929824561, age=5.917847566484826, total=69.42661949630939\nTicket 251 scores: category=15, plan=10, project_rev=2.1052631578947367, user_rev=2.770083102493075, age=1.811804780318724, total=31.687151040706535\nTicket 139 scores: category=25, plan=10, project_rev=11.428571428571427, user_rev=2.0050125313283207, age=0.0, total=48.43358395989975\nStored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Support Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 287}]\n",
        "code_error": null
      },
      {
        "message": "I've successfully prioritized the support tickets based on the given criteria. The tickets are now sorted by their total priority score, which considers:\n- Category severity (with downtime being highest priority)\n- Plan type (with advanced plans getting higher priority)\n- Revenue impact (both project-specific and total user revenue)\n- Ticket age (with newer tickets getting higher priority)\n\nHere are the prioritized tickets in order of importance:\n<artifact identifier='prioritized_tickets' warning='I cannot see the full data so I must not make up observations' />\n\nFrom the scoring output, we can see that ticket #143 received the highest total score (75.0) due to being a downtime issue (25 points), from a base plan customer (10 points), with high user revenue impact (20 points), and being the newest ticket (20 points).",
        "plan": null,
        "code": null,
        "code_output": null,
        "code_error": null
      }
    ],
    "modified_artifacts": [
      {
        "identifier": "prioritized_tickets",
        "title": "Prioritized Support Tickets",
        "artifact_type": "table",
        "data": [
          {
            "ticket_id": 143
          },
          {
            "ticket_id": 287
          },
          {
            "ticket_id": 286
          },
          {
            "ticket_id": 169
          },
          {
            "ticket_id": 166
          },
          {
            "ticket_id": 139
          },
          {
            "ticket_id": 288
          },
          {
            "ticket_id": 209
          },
          {
            "ticket_id": 251
          },
          {
            "ticket_id": 289
          }
        ]
      }
    ]
  }
]