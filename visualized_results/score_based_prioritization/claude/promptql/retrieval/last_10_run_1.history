[
  {
    "user_message": {
      "text": "Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. \n\nFor each ticket do the following:\n- get the description of the ticket\n- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs\n- get the plan the project is most recently on\n- get the total amount of revenue generated by the project (include invoice items of all types)\n- get the email of the user creating the ticket\n- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)\n- get the created at time of the ticket\n- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.\n\nCategory descriptions for AI Classification instructions:\n\n1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.\n\n2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.\n\n3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. \n\n4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  \n\n5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. \n\n6. Others: Any other type of ticket which does not fit the above categories\n\n- Then sort the tickets in order of priority using the following scoring:\n\n1. Category Weight (0-25 points):\n- Downtime: 25 points\n- Reliability: 20 points\n- Performance: 15 points\n- Bug: 10 points\n- Feature Request: 5 points\n- Others: 0 points\n\n2. Plan Weight (0-15 points):\n- advanced: 15 points\n- base: 10 points\n- free: 0 points\n\n3. Revenue Impact (0-40 points total):\n- Project Revenue: Up to 20 points (scaled relative to highest project revenue)\n- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)\n\n4. Age (0-20 points):\nLinear scale where:\n- Newest ticket = 20 points\n- Oldest ticket = 0 points\n- Other tickets scaled linearly between these points\n\n- Respond with an artifact with identifier \"prioritized_tickets\" containing sorted list of ticket IDs in the following format:\n[\n    {\n      \"ticket_id\": 1,\n    },\n    ...\n]\n"
    },
    "assistant_actions": [
      {
        "message": "I'll help you analyze and prioritize the support tickets.",
        "plan": "1. Get the last 10 open support tickets with their details, descriptions, and requester information\n2. For each ticket:\n   - Extract project ID from description using AI\n   - Get the most recent plan for each project\n   - Calculate project revenue from invoice items\n   - Get requester email and calculate their total revenue across all projects\n   - Classify ticket type using AI\n3. Calculate priority scores based on the given criteria\n4. Sort tickets by priority score and create the final artifact\n\nNote: All revenue calculations will be in the project's currency (assumed USD)",
        "code": "import datetime\nfrom functools import cmp_to_key\n\n# Get last 10 open tickets with details\nsql = \"\"\"\nSELECT \n    t.id as ticket_id,\n    t.subject,\n    t.description,\n    t.created_at,\n    u.email as requester_email\nFROM app.support_ticket t\nJOIN app.support_user u ON t.requester_id = u.id\nWHERE t.status = 'open'\nORDER BY t.created_at DESC\nLIMIT 10\n\"\"\"\ntickets = executor.run_sql(sql)\n\n# Extract project IDs using AI\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"project_id\": {\n            \"type\": \"string\",\n            \"description\": \"UUID of the project mentioned in the ticket\"\n        }\n    }\n}\nproject_ids = executor.extract(\n    json_schema=json_schema,\n    instructions=\"Extract the project ID (UUID) from the support ticket description. Return null if no valid UUID is found.\",\n    inputs=[ticket['description'] for ticket in tickets]\n)\n\n# Classify tickets\nclassifications = executor.classify(\n    instructions=\"\"\"\n    Classify support tickets into the following categories based on their subject and description:\n    \n    1. Downtime: Widespread service disruptions, inability to access services, production outages, API failures\n    2. Reliability: Intermittent connectivity issues, random failures, service instability\n    3. Performance: Slow response times, increased latency, slow processing\n    4. Bug: Software behavior issues, incorrect functionality\n    5. Feature request: Requests for new functionality or enhancements\n    6. Others: Any other type of ticket\n    \"\"\",\n    categories=['downtime', 'reliability', 'performance', 'bug', 'feature request', 'others'],\n    allow_multiple=False,\n    inputs=[f\"Subject: {t['subject']}\\nDescription: {t['description']}\" for t in tickets]\n)\n\n# Get project details and revenue\nproject_details = {}\nuser_total_revenue = {}\noldest_ticket = min(ticket['created_at'] for ticket in tickets)\nnewest_ticket = max(ticket['created_at'] for ticket in tickets)\ntime_range = (datetime.datetime.fromisoformat(newest_ticket) - datetime.datetime.fromisoformat(oldest_ticket)).total_seconds()\n\nfor ticket, extracted in zip(tickets, project_ids):\n    project_id = extracted.get('project_id')\n    if not project_id:\n        continue\n    \n    # Get most recent plan\n    sql = f\"\"\"\n    SELECT p.name as plan_name\n    FROM app.project_plan_changelogs c\n    JOIN app.plans p ON c.plan_id = p.id\n    WHERE c.project_id = '{project_id}'\n    ORDER BY c.created_at DESC\n    LIMIT 1\n    \"\"\"\n    plans = executor.run_sql(sql)\n    project_details[project_id] = {\n        'plan': plans[0]['plan_name'] if plans else 'free'\n    }\n    \n    # Get project revenue\n    sql = f\"\"\"\n    SELECT SUM(amount) as revenue\n    FROM app.invoice_item\n    WHERE project_id = '{project_id}'\n    \"\"\"\n    revenue = executor.run_sql(sql)\n    project_details[project_id]['revenue'] = float(revenue[0]['revenue'] or 0)\n    \n    # Get user's total revenue across all projects\n    if ticket['requester_email'] not in user_total_revenue:\n        sql = f\"\"\"\n        WITH user_projects AS (\n            SELECT p.id as project_id\n            FROM app.users u\n            JOIN app.projects p ON u.id = p.owner_id\n            WHERE u.email = '{ticket['requester_email']}'\n        )\n        SELECT SUM(amount) as total_revenue\n        FROM app.invoice_item i\n        WHERE i.project_id IN (SELECT project_id FROM user_projects)\n        \"\"\"\n        total_revenue = executor.run_sql(sql)\n        user_total_revenue[ticket['requester_email']] = float(total_revenue[0]['total_revenue'] or 0)\n\n# Find maximum revenues for scaling\nmax_project_revenue = max((details['revenue'] for details in project_details.values()), default=0)\nmax_user_revenue = max(user_total_revenue.values(), default=0)\n\n# Calculate priority scores\nticket_scores = []\nfor ticket, classification, extracted in zip(tickets, classifications, project_ids):\n    project_id = extracted.get('project_id')\n    \n    # Category score (0-25)\n    category_scores = {\n        'downtime': 25,\n        'reliability': 20,\n        'performance': 15,\n        'bug': 10,\n        'feature request': 5,\n        'others': 0\n    }\n    category_score = category_scores[classification]\n    \n    # Plan score (0-15)\n    plan_scores = {\n        'advanced': 15,\n        'base': 10,\n        'free': 0\n    }\n    plan_score = plan_scores[project_details.get(project_id, {}).get('plan', 'free')]\n    \n    # Revenue scores (0-40)\n    project_revenue = project_details.get(project_id, {}).get('revenue', 0)\n    project_revenue_score = (project_revenue / max_project_revenue * 20) if max_project_revenue > 0 else 0\n    \n    user_revenue = user_total_revenue.get(ticket['requester_email'], 0)\n    user_revenue_score = (user_revenue / max_user_revenue * 20) if max_user_revenue > 0 else 0\n    \n    # Age score (0-20)\n    ticket_age = (datetime.datetime.fromisoformat(newest_ticket) - datetime.datetime.fromisoformat(ticket['created_at'])).total_seconds()\n    age_score = 20 * (1 - (ticket_age / time_range)) if time_range > 0 else 20\n    \n    total_score = category_score + plan_score + project_revenue_score + user_revenue_score + age_score\n    ticket_scores.append({\n        'ticket_id': ticket['ticket_id'],\n        'score': total_score\n    })\n\n# Sort by score descending\nsorted_tickets = sorted(ticket_scores, key=lambda x: x['score'], reverse=True)\n\n# Create final artifact with just ticket IDs\nprioritized_tickets = [{'ticket_id': t['ticket_id']} for t in sorted_tickets]\nexecutor.store_artifact(\n    'prioritized_tickets',\n    'Prioritized Support Tickets',\n    'table',\n    prioritized_tickets\n)",
        "code_output": "SQL statement returned 10 rows.\nExtracted from 10 items\nClassified 10 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nStored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Support Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 287}]\n",
        "code_error": null
      },
      {
        "message": "Here are the support tickets sorted by priority based on the scoring criteria:\n<artifact identifier='prioritized_tickets' warning='I cannot see the full data so I must not make up observations' />\n\nThe tickets are ordered by their total priority score (0-100) which considers:\n- Ticket category (up to 25 points, with downtime being highest)\n- Project's plan tier (up to 15 points, with advanced plan being highest)\n- Revenue impact (up to 40 points, split between project and user revenue)\n- Ticket age (up to 20 points, with newer tickets scoring higher)\n\nWould you like to see more details about any specific ticket or understand how the scoring was calculated for particular cases?",
        "plan": null,
        "code": null,
        "code_output": null,
        "code_error": null
      }
    ],
    "modified_artifacts": [
      {
        "identifier": "prioritized_tickets",
        "title": "Prioritized Support Tickets",
        "artifact_type": "table",
        "data": [
          {
            "ticket_id": 143
          },
          {
            "ticket_id": 287
          },
          {
            "ticket_id": 286
          },
          {
            "ticket_id": 169
          },
          {
            "ticket_id": 166
          },
          {
            "ticket_id": 139
          },
          {
            "ticket_id": 288
          },
          {
            "ticket_id": 209
          },
          {
            "ticket_id": 251
          },
          {
            "ticket_id": 289
          }
        ]
      }
    ]
  }
]