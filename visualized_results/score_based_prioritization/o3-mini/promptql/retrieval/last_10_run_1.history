[
  {
    "user_message": {
      "text": "Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. \n\nFor each ticket do the following:\n- get the description of the ticket\n- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs\n- get the plan the project is most recently on\n- get the total amount of revenue generated by the project (include invoice items of all types)\n- get the email of the user creating the ticket\n- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)\n- get the created at time of the ticket\n- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.\n\nCategory descriptions for AI Classification instructions:\n\n1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.\n\n2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.\n\n3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. \n\n4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  \n\n5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. \n\n6. Others: Any other type of ticket which does not fit the above categories\n\n- Then sort the tickets in order of priority using the following scoring:\n\n1. Category Weight (0-25 points):\n- Downtime: 25 points\n- Reliability: 20 points\n- Performance: 15 points\n- Bug: 10 points\n- Feature Request: 5 points\n- Others: 0 points\n\n2. Plan Weight (0-15 points):\n- advanced: 15 points\n- base: 10 points\n- free: 0 points\n\n3. Revenue Impact (0-40 points total):\n- Project Revenue: Up to 20 points (scaled relative to highest project revenue)\n- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)\n\n4. Age (0-20 points):\nLinear scale where:\n- Newest ticket = 20 points\n- Oldest ticket = 0 points\n- Other tickets scaled linearly between these points\n\n- Respond with an artifact with identifier \"prioritized_tickets\" containing sorted list of ticket IDs in the following format:\n[\n    {\n      \"ticket_id\": 1,\n    },\n    ...\n]\n"
    },
    "assistant_actions": [
      {
        "message": "I'll start by retrieving the 10 most recent open support tickets. For each ticket we will:\n\n1. Get the ticket\u2019s description and extract the project ID (a UUID) using our extraction function.\n2. For the identified project, retrieve:\n\u2003 \u2022 its most recent plan change (to get the plan: \"advanced\", \"base\", or \"free\"),\n\u2003 \u2022 the project\u2019s total revenue (summing all related invoice items).\n3. Retrieve the ticket creator\u2019s email from the support user lookup.\n4. Using the creator\u2019s email, compute the total revenue generated across all projects owned by that user.\n5. Classify the ticket (using AI classification) into one of the six categories.\n6. Compute a priority score for each ticket based on:\n\u2003 \u2022 Category weight (using the provided weight values),\n\u2003 \u2022 Plan weight,\n\u2003 \u2022 Scaled revenue impact (project revenue and user\u2019s total revenue, each scaled to a max of 20 points based on the highest revenue among the tickets),\n\u2003 \u2022 Age weight (newer tickets get up to 20 points, older tickets get 0, with a linear scale in between).\n7. Finally, sort the tickets in descending order of score and return an artifact that lists the sorted ticket IDs.\n\nI'll now execute these steps. Note that this process involves several database queries and AI function calls for extraction and classification.",
        "plan": "1. Retrieve the 10 most recent open support tickets (fields: id, description, requester_id, created_at).\n2. For each ticket:\n    a. Use the extraction function to extract project_id (a UUID) from the ticket description. We define a JSON schema requiring a project_id.\n    b. Query for the most recent plan for the extracted project using the joined tables of plan changelogs and plans. If none is found, we assume the project is on the \"free\" plan.\n    c. Query the invoice_item table to sum the revenue for that project.\n    d. Query the support_user table to get the email for the ticket creator (using requester_id).\n    e. Query the revenue across all projects for that user by joining projects, invoice_item, and users (matching on email).\n    f. Use the classification function to classify the ticket description into one of the categories.\n3. After processing all tickets, compute:\n    a. The maximum project revenue and the maximum user revenue among the tickets.\n    b. The age weight: determine the newest and oldest ticket created_at times and then scale each ticket\u2019s age.\n4. Calculate the total priority score for each ticket based on:\n    - Category weight: Downtime: 25, Reliability: 20, Performance: 15, Bug: 10, Feature request: 5, Others: 0.\n    - Plan weight: advanced: 15, base: 10, free: 0.\n    - Project revenue points: up to 20 (scaled relative to highest project revenue).\n    - User revenue points: up to 20 (scaled relative to highest user revenue).\n    - Age weight: new (20 points) to old (0 points) linearly.\n5. Sort the tickets by total score descending.\n6. Save the sorted list of ticket IDs (in the required format) as an artifact with identifier \"prioritized_tickets\".",
        "code": "import datetime\nimport re\n\n# Mapping for category to weight\ncategory_weights = {\n    \"downtime\": 25,\n    \"reliability\": 20,\n    \"performance\": 15,\n    \"bug\": 10,\n    \"feature request\": 5,\n    \"others\": 0,\n}\n\n# Mapping for plan to weight\nplan_weights = {\n    \"advanced\": 15,\n    \"base\": 10,\n    \"free\": 0,\n}\n\n# Step 1: Retrieve the 10 most recent open support tickets.\ntickets_sql = \"\"\"\n    SELECT id, description, requester_id, created_at\n    FROM app.support_ticket\n    WHERE status = 'open'\n    ORDER BY created_at DESC\n    LIMIT 10\n\"\"\"\ntickets = executor.run_sql(tickets_sql)\n\nif not tickets:\n    executor.print(\"No open support tickets found.\")\n    # Create an empty artifact.\n    executor.store_artifact(\n        identifier=\"prioritized_tickets\",\n        title=\"Prioritized Support Tickets\",\n        artifact_type=\"table\",\n        data=[]\n    )\n    exit(0)\n\ntickets_data = []\n\n# Predefine JSON schema and extraction instructions for extracting a UUID (project ID) from the description.\nuuid_extraction_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"project_id\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\"\n        }\n    },\n    \"required\": [\"project_id\"]\n}\nuuid_extraction_instructions = \"Extract the project UUID from the ticket description.\"\n\n# Prepare classification instructions and categories.\nclassification_instructions = \"\"\"\nAnalyze the ticket description and determine the category of the support issue.\nCategories:\n1. Downtime: Widespread service disruptions and inability to access services.\n2. Reliability: Intermittent connectivity or random failures.\n3. Performance: Degraded performance or increased latency.\n4. Bug: Software malfunctions.\n5. Feature request: Requests for product enhancements.\n6. Others: Anything that does not fall into the above.\n\"\"\"\ncategories_list = [\"downtime\", \"reliability\", \"performance\", \"bug\", \"feature request\", \"others\"]\n\n# We'll collect timestamps to compute age weight later.\ncreated_times = []\n\n# Process each ticket.\nfor ticket in tickets:\n    ticket_id = ticket[\"id\"]\n    description = ticket[\"description\"]\n    requester_id = ticket[\"requester_id\"]\n    created_at_str = ticket[\"created_at\"]\n    try:\n        ticket_created = datetime.datetime.fromisoformat(created_at_str)\n    except Exception as e:\n        ticket_created = datetime.datetime.utcnow()  # fallback in case of error\n    created_times.append(ticket_created)\n    \n    # a. Extract project_id from description using extract AI function.\n    extraction_result = executor.extract(\n        json_schema=uuid_extraction_schema,\n        instructions=uuid_extraction_instructions,\n        inputs=[description]\n    )\n    # Assume extraction returns a list with one dict.\n    if extraction_result and isinstance(extraction_result, list) and extraction_result[0].get(\"project_id\"):\n        project_id = extraction_result[0][\"project_id\"]\n    else:\n        # If not found, set to None (and continue)\n        project_id = None\n\n    # b. Get the most recent plan for the project.\n    if project_id:\n        plan_sql = f\"\"\"\n            SELECT p.name AS plan_name\n            FROM app.project_plan_changelogs AS ch\n            JOIN app.plans AS p ON ch.plan_id = p.id\n            WHERE ch.project_id = '{project_id}'\n            ORDER BY ch.created_at DESC\n            LIMIT 1\n        \"\"\"\n        plan_res = executor.run_sql(plan_sql)\n        if plan_res and len(plan_res) > 0 and plan_res[0].get(\"plan_name\"):\n            plan_name = plan_res[0][\"plan_name\"].lower()\n        else:\n            plan_name = \"free\"\n    else:\n        plan_name = \"free\"\n    \n    # c. Get total project revenue from invoice items.\n    project_revenue_sql = f\"\"\"\n        SELECT COALESCE(SUM(amount), 0) AS revenue\n        FROM app.invoice_item\n        WHERE project_id = '{project_id}' \n    \"\"\"\n    proj_rev_res = executor.run_sql(project_revenue_sql)\n    project_revenue = float(proj_rev_res[0][\"revenue\"]) if proj_rev_res and proj_rev_res[0].get(\"revenue\") is not None else 0.0\n\n    # d. Get the email of the ticket creator from support_user.\n    support_user_sql = f\"\"\"\n        SELECT email\n        FROM app.support_user\n        WHERE id = {requester_id}\n        LIMIT 1\n    \"\"\"\n    support_user_res = executor.run_sql(support_user_sql)\n    if support_user_res and len(support_user_res) > 0 and support_user_res[0].get(\"email\"):\n        user_email = support_user_res[0][\"email\"]\n    else:\n        user_email = \"\"\n    \n    # e. Get total revenue over all projects of the user.\n    user_revenue_sql = f\"\"\"\n        SELECT COALESCE(SUM(ii.amount), 0) AS revenue\n        FROM app.projects AS pr\n        JOIN app.invoice_item AS ii ON pr.id = ii.project_id\n        JOIN app.users AS u ON u.id = pr.owner_id\n        WHERE u.email = '{user_email}'\n        GROUP BY u.email\n        LIMIT 1\n    \"\"\"\n    user_rev_res = executor.run_sql(user_revenue_sql)\n    user_revenue = float(user_rev_res[0][\"revenue\"]) if user_rev_res and user_rev_res[0].get(\"revenue\") is not None else 0.0\n\n    # f. Classify the ticket (using the ticket description).\n    classification = executor.classify(\n        instructions=classification_instructions,\n        categories=categories_list,\n        allow_multiple=False,\n        inputs=[description]\n    )\n    # Assume classification returns a list with one string.\n    ticket_category = classification[0].lower() if classification and isinstance(classification, list) else \"others\"\n    if ticket_category not in category_weights:\n        ticket_category = \"others\"  # default if unexpected\n\n    # Collect ticket info.\n    tickets_data.append({\n        \"ticket_id\": ticket_id,\n        \"project_id\": project_id,\n        \"plan_name\": plan_name,\n        \"project_revenue\": project_revenue,\n        \"user_email\": user_email,\n        \"user_revenue\": user_revenue,\n        \"created_at\": ticket_created,\n        \"category\": ticket_category,\n        # We'll add scoring fields later.\n    })\n\n# Compute age scaling parameters.\nnewest = max(created_times)\noldest = min(created_times)\nage_range = (newest - oldest).total_seconds()\n# Also compute max revenues among tickets.\nmax_proj_rev = max(ticket[\"project_revenue\"] for ticket in tickets_data) if tickets_data else 0\nmax_user_rev = max(ticket[\"user_revenue\"] for ticket in tickets_data) if tickets_data else 0\n\n# Now compute total score for each ticket.\nfor ticket in tickets_data:\n    # Category weight.\n    cat_weight = category_weights.get(ticket[\"category\"], 0)\n    \n    # Plan weight.\n    plan_weight = plan_weights.get(ticket[\"plan_name\"], 0)\n    \n    # Project revenue points scaled to 20 points.\n    proj_rev_points = 20 * (ticket[\"project_revenue\"] / max_proj_rev) if max_proj_rev > 0 else 0\n    \n    # User revenue points scaled to 20 points.\n    user_rev_points = 20 * (ticket[\"user_revenue\"] / max_user_rev) if max_user_rev > 0 else 0\n    \n    # Age weight: scale created_at from oldest (0) to newest (20) linearly.\n    # If all tickets are at the same time, assign 20.\n    if age_range > 0:\n        age_weight = 20 * ((ticket[\"created_at\"] - oldest).total_seconds() / age_range)\n    else:\n        age_weight = 20\n    # Total score.\n    total_score = cat_weight + plan_weight + proj_rev_points + user_rev_points + age_weight\n    ticket[\"total_score\"] = total_score\n\n# Sort tickets in descending order of score.\ntickets_sorted = sorted(tickets_data, key=lambda x: x[\"total_score\"], reverse=True)\n\n# Prepare final artifact data.\nartifact_data = [{\"ticket_id\": t[\"ticket_id\"]} for t in tickets_sorted]\n\nexecutor.store_artifact(\n    identifier=\"prioritized_tickets\",\n    title=\"Prioritized Support Tickets\",\n    artifact_type=\"table\",\n    data=artifact_data\n)\n\nexecutor.print(\"Stored prioritized tickets artifact.\")",
        "code_output": "SQL statement returned 10 rows.\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 0 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 0 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nExtracted from 1 items\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nSQL statement returned 1 rows.\nClassified 1 items\nStored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Support Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 286}]\nStored prioritized tickets artifact.\n",
        "code_error": null
      },
      {
        "message": "Here is the sorted list of prioritized ticket IDs:\n<artifact identifier = 'prioritized_tickets' />",
        "plan": null,
        "code": null,
        "code_output": null,
        "code_error": null
      }
    ],
    "modified_artifacts": [
      {
        "identifier": "prioritized_tickets",
        "title": "Prioritized Support Tickets",
        "artifact_type": "table",
        "data": [
          {
            "ticket_id": 143
          },
          {
            "ticket_id": 286
          },
          {
            "ticket_id": 169
          },
          {
            "ticket_id": 166
          },
          {
            "ticket_id": 139
          },
          {
            "ticket_id": 287
          },
          {
            "ticket_id": 288
          },
          {
            "ticket_id": 209
          },
          {
            "ticket_id": 251
          },
          {
            "ticket_id": 289
          }
        ]
      }
    ]
  }
]