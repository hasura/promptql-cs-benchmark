
    <!DOCTYPE html>
    <html>
    <head>
        <title>Model Comparison</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                margin: 20px; 
                background-color: #f5f5f5;
            }
            .container { 
                display: flex; 
                gap: 20px; 
                margin-bottom: 40px;
                height: calc(100vh - 100px); /* Adjust for top margin and title space */
            }
            .system-column {
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            .sticky-header {
                position: sticky;
                top: 0;
                background-color: #ffffff;
                padding: 20px;
                margin-bottom: 15px;
                z-index: 100;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                border-bottom: 1px solid #e6e6e6;
                border-radius: 8px 8px 0 0;
            }
            .system-title {
                display: inline-block;
                margin: 0;
                margin-right: 10px;
                font-weight: bold;
                font-size: 1.3em;
                color: #2c3e50;
            }
            .system { 
                flex: 1; 
                border: 1px solid #ccc; 
                padding: 15px;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                display: flex;
                flex-direction: column;
                max-height: 100%;
                overflow-y: auto;
                # margin-top: 10px;
            }
            .execution-time {
                font-size: 16px;
                margin-left: 5px;
                display: inline;
                color: #666;
            }
            .message { 
                margin: 10px 0; 
                padding: 10px; 
                border-radius: 5px; 
            }
            .user { 
                background-color: #f0f0f0; 
                border-left: 4px solid #007bff;
            }
            .assistant { 
                background-color: #e6f3ff; 
                border-left: 4px solid #28a745;
            }
            .section-title {
                font-weight: bold;
                margin-top: 10px;
                margin-bottom: 5px;
            }
            pre { 
                white-space: pre-wrap; 
                word-wrap: break-word; 
                margin: 5px 0;
            }
            h2, h3 { color: #333; }
            .timestamp { 
                color: #666; 
                font-style: italic; 
                margin-bottom: 20px;
            }
            .collapsible {
                background-color: #f8f9fa;
                cursor: pointer;
                padding: 10px;
                width: 100%;
                border: none;
                text-align: left;
                outline: none;
                margin-top: 5px;
                border-radius: 4px;
            }
            .active, .collapsible:hover {
                background-color: #e9ecef;
            }
            .content {
                padding: 0 18px;
                display: none;
                overflow: hidden;
                background-color: #f8f9fa;
                border-radius: 0 0 4px 4px;
            }
            /* Tab styles */
            .tabs {
                margin-top: 20px;
                margin-bottom: 20px;
                border-bottom: 1px solid #ddd;
            }
            .tab-button {
                background-color: #f8f9fa;
                border: 1px solid #ddd;
                border-bottom: none;
                padding: 10px 20px;
                cursor: pointer;
                margin-right: 5px;
                border-radius: 4px 4px 0 0;
            }
            .tab-button.active {
                background-color: #fff;
                border-bottom: 1px solid #fff;
                margin-bottom: -1px;
            }
            .tab-content {
                display: none;
            }
            .tab-content.active {
                display: block;
            }
            .result-section {
                padding: 15px;
                background-color: #f8f9fa;
                border-left: 4px solid #6c757d;
                border-radius: 5px;
            }
            .result-section .section-title {
                color: #495057;
                font-size: 1.1em;
                margin-bottom: 10px;
            }
            .result-section pre {
                background-color: #fff;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #dee2e6;
                color: #212529;
                font-family: 'Consolas', 'Monaco', monospace;
            }
            .title-container {
                display: flex;
                align-items: center;
                gap: 30px;
            }
            .back-link {
                text-decoration: none;
                color: #666;
                font-size: 14px;
            }
            .back-link:hover {
                color: #333;
            }
            .separator {
                height: 2px;
                background-color: #ccc;
                margin: 20px 0;
                width: 100%;
                align-self: stretch;
                flex-shrink: 0;
                display: block;
            }
        </style>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                // Collapsible sections
                var coll = document.getElementsByClassName("collapsible");
                for (var i = 0; i < coll.length; i++) {
                    coll[i].addEventListener("click", function() {
                        this.classList.toggle("active");
                        var content = this.nextElementSibling;
                        if (content.style.display === "block") {
                            content.style.display = "none";
                        } else {
                            content.style.display = "block";
                        }
                    });
                }

                // Tab functionality
                var tabButtons = document.getElementsByClassName("tab-button");
                for (var i = 0; i < tabButtons.length; i++) {
                    tabButtons[i].addEventListener("click", function() {
                        var runId = this.getAttribute("data-run");
                        
                        // Deactivate all tabs
                        var allTabs = document.getElementsByClassName("tab-button");
                        for (var j = 0; j < allTabs.length; j++) {
                            allTabs[j].classList.remove("active");
                        }
                        
                        // Deactivate all content
                        var allContent = document.getElementsByClassName("tab-content");
                        for (var j = 0; j < allContent.length; j++) {
                            allContent[j].classList.remove("active");
                        }
                        
                        // Activate selected tab and content
                        this.classList.add("active");
                        document.getElementById("run-" + runId).classList.add("active");
                    });
                }

                // Activate first tab by default
                if (tabButtons.length > 0) {
                    tabButtons[0].click();
                }
            });
        </script>
    </head>
    <body>
    <div class="title-container">
        <h1>With O3-MINI</h1>
        <a href="index.html" class="back-link">&larr;Back</a>
    </div><div class='timestamp'>Generated on: 2025-02-21 14:59:18</div><div class='tabs'><button class='tab-button' data-run='1'>Run 1</button><button class='tab-button' data-run='2'>Run 2</button><button class='tab-button' data-run='3'>Run 3</button></div><div id='run-1' class='tab-content'><div class='container'><div class='system-column'><div class='sticky-header'><h3 class='system-title'>promptql</h3><span class='execution-time'>(Execution time: 2m 10s)</span></div><div class='system'><div class='message user'><strong>User:</strong><pre>Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. 

For each ticket do the following:
- get the description of the ticket
- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the total amount of revenue generated by the project (include invoice items of all types)
- get the email of the user creating the ticket
- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)
- get the created at time of the ticket
- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Category descriptions for AI Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

- Then sort the tickets in order of priority using the following scoring:

1. Category Weight (0-25 points):
- Downtime: 25 points
- Reliability: 20 points
- Performance: 15 points
- Bug: 10 points
- Feature Request: 5 points
- Others: 0 points

2. Plan Weight (0-15 points):
- advanced: 15 points
- base: 10 points
- free: 0 points

3. Revenue Impact (0-40 points total):
- Project Revenue: Up to 20 points (scaled relative to highest project revenue)
- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)

4. Age (0-20 points):
Linear scale where:
- Newest ticket = 20 points
- Oldest ticket = 0 points
- Other tickets scaled linearly between these points

- Respond with an artifact with identifier "prioritized_tickets" containing sorted list of ticket IDs in the following format:
[
    {
      "ticket_id": 1,
    },
    ...
]
</pre></div><div class='message assistant'><strong>Assistant:</strong><pre>I'll start by retrieving the 10 most recent open support tickets. For each ticket we will:

1. Get the ticket’s description and extract the project ID (a UUID) using our extraction function.
2. For the identified project, retrieve:
  • its most recent plan change (to get the plan: "advanced", "base", or "free"),
  • the project’s total revenue (summing all related invoice items).
3. Retrieve the ticket creator’s email from the support user lookup.
4. Using the creator’s email, compute the total revenue generated across all projects owned by that user.
5. Classify the ticket (using AI classification) into one of the six categories.
6. Compute a priority score for each ticket based on:
  • Category weight (using the provided weight values),
  • Plan weight,
  • Scaled revenue impact (project revenue and user’s total revenue, each scaled to a max of 20 points based on the highest revenue among the tickets),
  • Age weight (newer tickets get up to 20 points, older tickets get 0, with a linear scale in between).
7. Finally, sort the tickets in descending order of score and return an artifact that lists the sorted ticket IDs.

I'll now execute these steps. Note that this process involves several database queries and AI function calls for extraction and classification.

</pre><div class="section-title">Plan:</div><pre>1. Retrieve the 10 most recent open support tickets (fields: id, description, requester_id, created_at).
2. For each ticket:
    a. Use the extraction function to extract project_id (a UUID) from the ticket description. We define a JSON schema requiring a project_id.
    b. Query for the most recent plan for the extracted project using the joined tables of plan changelogs and plans. If none is found, we assume the project is on the "free" plan.
    c. Query the invoice_item table to sum the revenue for that project.
    d. Query the support_user table to get the email for the ticket creator (using requester_id).
    e. Query the revenue across all projects for that user by joining projects, invoice_item, and users (matching on email).
    f. Use the classification function to classify the ticket description into one of the categories.
3. After processing all tickets, compute:
    a. The maximum project revenue and the maximum user revenue among the tickets.
    b. The age weight: determine the newest and oldest ticket created_at times and then scale each ticket’s age.
4. Calculate the total priority score for each ticket based on:
    - Category weight: Downtime: 25, Reliability: 20, Performance: 15, Bug: 10, Feature request: 5, Others: 0.
    - Plan weight: advanced: 15, base: 10, free: 0.
    - Project revenue points: up to 20 (scaled relative to highest project revenue).
    - User revenue points: up to 20 (scaled relative to highest user revenue).
    - Age weight: new (20 points) to old (0 points) linearly.
5. Sort the tickets by total score descending.
6. Save the sorted list of ticket IDs (in the required format) as an artifact with identifier "prioritized_tickets".

</pre><div class="section-title">Code:</div><button class="collapsible">Show Code +</button><div class="content"><pre>import datetime
import re

# Mapping for category to weight
category_weights = {
    "downtime": 25,
    "reliability": 20,
    "performance": 15,
    "bug": 10,
    "feature request": 5,
    "others": 0,
}

# Mapping for plan to weight
plan_weights = {
    "advanced": 15,
    "base": 10,
    "free": 0,
}

# Step 1: Retrieve the 10 most recent open support tickets.
tickets_sql = """
    SELECT id, description, requester_id, created_at
    FROM app.support_ticket
    WHERE status = 'open'
    ORDER BY created_at DESC
    LIMIT 10
"""
tickets = executor.run_sql(tickets_sql)

if not tickets:
    executor.print("No open support tickets found.")
    # Create an empty artifact.
    executor.store_artifact(
        identifier="prioritized_tickets",
        title="Prioritized Support Tickets",
        artifact_type="table",
        data=[]
    )
    exit(0)

tickets_data = []

# Predefine JSON schema and extraction instructions for extracting a UUID (project ID) from the description.
uuid_extraction_schema = {
    "type": "object",
    "properties": {
        "project_id": {
            "type": "string",
            "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
        }
    },
    "required": ["project_id"]
}
uuid_extraction_instructions = "Extract the project UUID from the ticket description."

# Prepare classification instructions and categories.
classification_instructions = """
Analyze the ticket description and determine the category of the support issue.
Categories:
1. Downtime: Widespread service disruptions and inability to access services.
2. Reliability: Intermittent connectivity or random failures.
3. Performance: Degraded performance or increased latency.
4. Bug: Software malfunctions.
5. Feature request: Requests for product enhancements.
6. Others: Anything that does not fall into the above.
"""
categories_list = ["downtime", "reliability", "performance", "bug", "feature request", "others"]

# We'll collect timestamps to compute age weight later.
created_times = []

# Process each ticket.
for ticket in tickets:
    ticket_id = ticket["id"]
    description = ticket["description"]
    requester_id = ticket["requester_id"]
    created_at_str = ticket["created_at"]
    try:
        ticket_created = datetime.datetime.fromisoformat(created_at_str)
    except Exception as e:
        ticket_created = datetime.datetime.utcnow()  # fallback in case of error
    created_times.append(ticket_created)
    
    # a. Extract project_id from description using extract AI function.
    extraction_result = executor.extract(
        json_schema=uuid_extraction_schema,
        instructions=uuid_extraction_instructions,
        inputs=[description]
    )
    # Assume extraction returns a list with one dict.
    if extraction_result and isinstance(extraction_result, list) and extraction_result[0].get("project_id"):
        project_id = extraction_result[0]["project_id"]
    else:
        # If not found, set to None (and continue)
        project_id = None

    # b. Get the most recent plan for the project.
    if project_id:
        plan_sql = f"""
            SELECT p.name AS plan_name
            FROM app.project_plan_changelogs AS ch
            JOIN app.plans AS p ON ch.plan_id = p.id
            WHERE ch.project_id = '{project_id}'
            ORDER BY ch.created_at DESC
            LIMIT 1
        """
        plan_res = executor.run_sql(plan_sql)
        if plan_res and len(plan_res) > 0 and plan_res[0].get("plan_name"):
            plan_name = plan_res[0]["plan_name"].lower()
        else:
            plan_name = "free"
    else:
        plan_name = "free"
    
    # c. Get total project revenue from invoice items.
    project_revenue_sql = f"""
        SELECT COALESCE(SUM(amount), 0) AS revenue
        FROM app.invoice_item
        WHERE project_id = '{project_id}' 
    """
    proj_rev_res = executor.run_sql(project_revenue_sql)
    project_revenue = float(proj_rev_res[0]["revenue"]) if proj_rev_res and proj_rev_res[0].get("revenue") is not None else 0.0

    # d. Get the email of the ticket creator from support_user.
    support_user_sql = f"""
        SELECT email
        FROM app.support_user
        WHERE id = {requester_id}
        LIMIT 1
    """
    support_user_res = executor.run_sql(support_user_sql)
    if support_user_res and len(support_user_res) > 0 and support_user_res[0].get("email"):
        user_email = support_user_res[0]["email"]
    else:
        user_email = ""
    
    # e. Get total revenue over all projects of the user.
    user_revenue_sql = f"""
        SELECT COALESCE(SUM(ii.amount), 0) AS revenue
        FROM app.projects AS pr
        JOIN app.invoice_item AS ii ON pr.id = ii.project_id
        JOIN app.users AS u ON u.id = pr.owner_id
        WHERE u.email = '{user_email}'
        GROUP BY u.email
        LIMIT 1
    """
    user_rev_res = executor.run_sql(user_revenue_sql)
    user_revenue = float(user_rev_res[0]["revenue"]) if user_rev_res and user_rev_res[0].get("revenue") is not None else 0.0

    # f. Classify the ticket (using the ticket description).
    classification = executor.classify(
        instructions=classification_instructions,
        categories=categories_list,
        allow_multiple=False,
        inputs=[description]
    )
    # Assume classification returns a list with one string.
    ticket_category = classification[0].lower() if classification and isinstance(classification, list) else "others"
    if ticket_category not in category_weights:
        ticket_category = "others"  # default if unexpected

    # Collect ticket info.
    tickets_data.append({
        "ticket_id": ticket_id,
        "project_id": project_id,
        "plan_name": plan_name,
        "project_revenue": project_revenue,
        "user_email": user_email,
        "user_revenue": user_revenue,
        "created_at": ticket_created,
        "category": ticket_category,
        # We'll add scoring fields later.
    })

# Compute age scaling parameters.
newest = max(created_times)
oldest = min(created_times)
age_range = (newest - oldest).total_seconds()
# Also compute max revenues among tickets.
max_proj_rev = max(ticket["project_revenue"] for ticket in tickets_data) if tickets_data else 0
max_user_rev = max(ticket["user_revenue"] for ticket in tickets_data) if tickets_data else 0

# Now compute total score for each ticket.
for ticket in tickets_data:
    # Category weight.
    cat_weight = category_weights.get(ticket["category"], 0)
    
    # Plan weight.
    plan_weight = plan_weights.get(ticket["plan_name"], 0)
    
    # Project revenue points scaled to 20 points.
    proj_rev_points = 20 * (ticket["project_revenue"] / max_proj_rev) if max_proj_rev > 0 else 0
    
    # User revenue points scaled to 20 points.
    user_rev_points = 20 * (ticket["user_revenue"] / max_user_rev) if max_user_rev > 0 else 0
    
    # Age weight: scale created_at from oldest (0) to newest (20) linearly.
    # If all tickets are at the same time, assign 20.
    if age_range > 0:
        age_weight = 20 * ((ticket["created_at"] - oldest).total_seconds() / age_range)
    else:
        age_weight = 20
    # Total score.
    total_score = cat_weight + plan_weight + proj_rev_points + user_rev_points + age_weight
    ticket["total_score"] = total_score

# Sort tickets in descending order of score.
tickets_sorted = sorted(tickets_data, key=lambda x: x["total_score"], reverse=True)

# Prepare final artifact data.
artifact_data = [{"ticket_id": t["ticket_id"]} for t in tickets_sorted]

executor.store_artifact(
    identifier="prioritized_tickets",
    title="Prioritized Support Tickets",
    artifact_type="table",
    data=artifact_data
)

executor.print("Stored prioritized tickets artifact.")

</pre></div><div class="section-title">Code Output:</div><button class="collapsible">Show Code Output +</button><div class="content"><pre>SQL statement returned 10 rows.
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 0 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 0 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Extracted from 1 items
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 1 items
Stored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Support Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 286}]
Stored prioritized tickets artifact.

</pre></div></div><div class='message assistant'><strong>Assistant:</strong><pre>Here is the sorted list of prioritized ticket IDs:
<artifact identifier = 'prioritized_tickets' />
</pre></div><div style='width: 100%;'><div class='separator'></div><div class='result-section'><div class='section-title'>Result:</div><pre>[
  {
    "ticket_id": 143
  },
  {
    "ticket_id": 286
  },
  {
    "ticket_id": 169
  },
  {
    "ticket_id": 166
  },
  {
    "ticket_id": 139
  },
  {
    "ticket_id": 287
  },
  {
    "ticket_id": 288
  },
  {
    "ticket_id": 209
  },
  {
    "ticket_id": 251
  },
  {
    "ticket_id": 289
  }
]</pre></div></div></div></div><div class='system-column'><div class='sticky-header'><h3 class='system-title'>tool_calling</h3></div><div class='system'><p>Run not found</p></div></div><div class='system-column'><div class='sticky-header'><h3 class='system-title'>tool_calling_python</h3></div><div class='system'><p>Run not found</p></div></div></div></div><div id='run-2' class='tab-content'><div class='container'><div class='system-column'><div class='sticky-header'><h3 class='system-title'>promptql</h3><span class='execution-time'>(Execution time: 1m 0s)</span></div><div class='system'><div class='message user'><strong>User:</strong><pre>Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. 

For each ticket do the following:
- get the description of the ticket
- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the total amount of revenue generated by the project (include invoice items of all types)
- get the email of the user creating the ticket
- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)
- get the created at time of the ticket
- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Category descriptions for AI Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

- Then sort the tickets in order of priority using the following scoring:

1. Category Weight (0-25 points):
- Downtime: 25 points
- Reliability: 20 points
- Performance: 15 points
- Bug: 10 points
- Feature Request: 5 points
- Others: 0 points

2. Plan Weight (0-15 points):
- advanced: 15 points
- base: 10 points
- free: 0 points

3. Revenue Impact (0-40 points total):
- Project Revenue: Up to 20 points (scaled relative to highest project revenue)
- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)

4. Age (0-20 points):
Linear scale where:
- Newest ticket = 20 points
- Oldest ticket = 0 points
- Other tickets scaled linearly between these points

- Respond with an artifact with identifier "prioritized_tickets" containing sorted list of ticket IDs in the following format:
[
    {
      "ticket_id": 1,
    },
    ...
]
</pre></div><div class='message assistant'><strong>Assistant:</strong><pre>I'll now retrieve the last 10 open support tickets and, for each, pull together the detailed information (including extracting the project ID from the description, retrieving the latest plan details, computing revenue figures both for the project and for the user who created the ticket, and classifying the ticket category). Then I'll compute a priority score based on the scoring rules and finally return a sorted list of ticket IDs in descending order of priority.

</pre><div class="section-title">Plan:</div><pre>1. Query the 10 most recent open support tickets (status = 'open') from the support ticket table (selecting id, description, created_at, requester_id).
2. For each ticket:
   a. Use a regular expression to extract a project ID (UUID) from the ticket description. If none is found, we'll assume the project is on a "free" plan and has zero revenue.
   b. If a project ID is found:
       - Query the most recent project plan changelog for that project (ordered by created_at descending, limit 1). If found, then query the plans table to get the plan name; if not found, default to "free".
       - Query the invoice_item table to sum the amount for that project as the project’s total revenue.
   c. Retrieve the ticket creator's email by using the requester_id from the support ticket via the support_user table.
   d. For the ticket creator, using the email, retrieve the corresponding user record in the users table. Then, query the projects table using the owner's id to list all projects and sum revenue from invoice_item for all those projects as the user's total revenue.
3. Use the extracted ticket description to call the classify function with the provided category definitions to classify each ticket into one of the following: downtime, reliability, performance, bug, feature request, others.
4. Compute priority scores for each ticket:
   - Category Weight: assign points based on the category.
   - Plan Weight: assign 15 for "advanced", 10 for "base" and 0 for "free".
   - Revenue Impact:
       • Project Revenue: scaled to a maximum of 20 points relative to the highest project revenue among these tickets.
       • User Total Revenue: scaled to a maximum of 20 points relative to the highest user revenue.
   - Age: scale linearly from 0 to 20, where the newest ticket gets 20 and the oldest gets 0.
5. Sort the tickets descending by their total score.
6. Store an artifact with identifier "prioritized_tickets" that is a list of objects containing only the ticket IDs in order:
   [
      { "ticket_id": <id> },
      ...
   ]
Assumptions:
• The project ID, when present, is in a standard UUID format.
• If any piece of information (e.g. project plan changelog or revenue) is missing, default values will be used.
• Dates are compared using UTC.

</pre><div class="section-title">Code:</div><button class="collapsible">Show Code +</button><div class="content"><pre>import re
import datetime

# Helper function to convert timestamp string to datetime object
def parse_timestamp(ts_str):
    # timestamps are stored as ISO strings, e.g. '2025-02-20T10:42:33.573625-08:00'
    try:
        # Use fromisoformat which handles timezone info
        return datetime.datetime.fromisoformat(ts_str)
    except Exception as e:
        return None

# Category weight mapping
category_weights = {
    "downtime": 25,
    "reliability": 20,
    "performance": 15,
    "bug": 10,
    "feature request": 5,
    "others": 0,
}

# Plan weight mapping
plan_weights = {
    "advanced": 15,
    "base": 10,
    "free": 0,
}

# Step 1: Query the 10 most recent open support tickets
ticket_sql = """
    SELECT id, description, created_at, requester_id
    FROM app.support_ticket
    WHERE status = 'open'
    ORDER BY created_at DESC
    LIMIT 10
"""
tickets = executor.run_sql(ticket_sql)

# Prepare list to hold processed ticket data
processed_tickets = []

# Compile regex to extract UUID (project ID)
uuid_regex = re.compile(r"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")

# Gather ticket descriptions for classification later
ticket_descriptions = []

# Process each ticket
for ticket in tickets:
    ticket_id = ticket.get("id")
    description = ticket.get("description", "")
    created_at_str = ticket.get("created_at")
    created_at = parse_timestamp(created_at_str) if created_at_str else None
    requester_id = ticket.get("requester_id")
    
    # Extract project ID using regex
    m = uuid_regex.search(description)
    project_id = m.group(0) if m else None
    
    # Initialize defaults
    plan_name = "free"
    project_revenue = 0.0
    if project_id:
        # Retrieve most recent plan changelog for the project
        plan_changelog_sql = f"""
            SELECT plan_id, created_at
            FROM app.project_plan_changelogs
            WHERE project_id = '{project_id}'
            ORDER BY created_at DESC
            LIMIT 1
        """
        changelogs = executor.run_sql(plan_changelog_sql)
        if changelogs and len(changelogs) > 0:
            plan_id = changelogs[0].get("plan_id")
            # Retrieve the plan name from app.plans table
            plan_sql = f"""
                SELECT name
                FROM app.plans
                WHERE id = '{plan_id}'
                LIMIT 1
            """
            plan_res = executor.run_sql(plan_sql)
            if plan_res and len(plan_res) > 0:
                plan_name = plan_res[0].get("name", "free").lower()
        # Retrieve project revenue from invoice items for this project
        revenue_sql = f"""
            SELECT SUM(amount) AS project_revenue
            FROM app.invoice_item
            WHERE project_id = '{project_id}'
        """
        revenue_res = executor.run_sql(revenue_sql)
        if revenue_res and revenue_res[0].get("project_revenue") is not None:
            try:
                project_revenue = float(revenue_res[0]["project_revenue"])
            except:
                project_revenue = 0.0
                
    # Get requester email from support_user table using requester_id
    requester_email = ""
    if requester_id is not None:
        req_sql = f"""
            SELECT email
            FROM app.support_user
            WHERE id = {requester_id}
            LIMIT 1
        """
        req_res = executor.run_sql(req_sql)
        if req_res and len(req_res) > 0:
            requester_email = req_res[0].get("email", "")
    
    # For the user's total revenue, we'll:
    # 1. Retrieve the corresponding user in app.users using email
    user_total_revenue = 0.0
    user_id = None
    if requester_email:
        user_sql = f"""
            SELECT id
            FROM app.users
            WHERE email = '{requester_email}'
            LIMIT 1
        """
        user_res = executor.run_sql(user_sql)
        if user_res and len(user_res) > 0:
            user_id = user_res[0].get("id")
    # 2. If user_id is found, retrieve all projects where owner_id = user_id and then sum revenue from invoice items
    if user_id:
        projects_sql = f"""
            SELECT id
            FROM app.projects
            WHERE owner_id = '{user_id}'
        """
        projects_res = executor.run_sql(projects_sql)
        project_ids = [proj["id"] for proj in projects_res] if projects_res else []
        # Sum revenue for each project
        total = 0.0
        for pid in project_ids:
            proj_rev_sql = f"""
                SELECT SUM(amount) AS revenue
                FROM app.invoice_item
                WHERE project_id = '{pid}'
            """
            proj_rev_res = executor.run_sql(proj_rev_sql)
            if proj_rev_res and proj_rev_res[0].get("revenue") is not None:
                try:
                    total += float(proj_rev_res[0]["revenue"])
                except:
                    pass
        user_total_revenue = total

    # Append ticket description for classification
    ticket_descriptions.append(description)
    
    processed_tickets.append({
        "ticket_id": ticket_id,
        "description": description,
        "project_id": project_id,
        "plan_name": plan_name,  # should be in lower case for our mapping
        "project_revenue": project_revenue,
        "requester_email": requester_email,
        "user_total_revenue": user_total_revenue,
        "created_at": created_at,  # datetime object for later age scaling
        "created_at_str": created_at_str  # keep original string if needed later
    })

# Step 3: Classify each ticket into a category using the provided category definitions.
classification_instructions = """
Classify the text (ticket description) into one of the following categories based on these definitions:
1. Downtime: Widespread service disruptions or inability to access project consoles or GraphQL endpoints,
   with production outages, 500 errors, and timeouts.
2. Reliability: Intermittent connectivity issues, random request failures, or instability affecting system reliability.
3. Performance: Issues related to increased latency or significantly slower response times in GraphQL queries or other operations.
4. Bug: Reports of errors or unexpected behavior in software functions.
5. Feature request: Requests for additional functionalities or enhancements.
6. Others: Any ticket that does not clearly fit the above categories.

Return exactly one category from: downtime, reliability, performance, bug, feature request, others.
"""
classifications = executor.classify(
    instructions=classification_instructions,
    categories=['downtime', 'reliability', 'performance', 'bug', 'feature request', 'others'],
    allow_multiple=False,
    inputs=ticket_descriptions
)

# Add classification to processed ticket info (ensure lower case for mapping)
for idx, ticket in enumerate(processed_tickets):
    classification = classifications[idx].lower() if classifications[idx] else "others"
    ticket["category"] = classification

# Step 4: Compute scoring components for each ticket.
# First, compute max project revenue and max user total revenue among the tickets
max_proj_rev = max([t["project_revenue"] for t in processed_tickets] or [0])
max_user_rev = max([t["user_total_revenue"] for t in processed_tickets] or [0])

# For age scoring, get the min and max created_at timestamps (in epoch)
# We'll ignore tickets that might have None for created_at; if all None, assign full age score.
valid_timestamps = [t["created_at"].timestamp() for t in processed_tickets if t["created_at"] is not None]
if valid_timestamps:
    max_time = max(valid_timestamps)
    min_time = min(valid_timestamps)
    time_range = (max_time - min_time) if (max_time - min_time) != 0 else 1
else:
    max_time = min_time = 0
    time_range = 1

# Now calculate score for each ticket
for t in processed_tickets:
    # Category weight
    cat_weight = category_weights.get(t["category"], 0)
    
    # Plan weight (ensure lower case matching)
    plan_weight = plan_weights.get(t["plan_name"].lower(), 0)
    
    # Project revenue score: scale to 20 points
    proj_rev_score = (t["project_revenue"] / max_proj_rev * 20) if max_proj_rev > 0 else 0
    
    # User total revenue: scale to 20 points
    user_rev_score = (t["user_total_revenue"] / max_user_rev * 20) if max_user_rev > 0 else 0
    
    # Age score: newest gets 20, oldest gets 0 - linear scale based on created_at timestamp
    if t["created_at"]:
        t_epoch = t["created_at"].timestamp()
        age_score = ((t_epoch - min_time) / time_range) * 20
    else:
        age_score = 0
    # Total score:
    t["score"] = cat_weight + plan_weight + proj_rev_score + user_rev_score + age_score

# Step 5: Sort tickets descending by score
processed_tickets.sort(key=lambda x: x["score"], reverse=True)

# Step 6: Prepare artifact output with sorted list of ticket IDs
sorted_ticket_ids = [{"ticket_id": t["ticket_id"]} for t in processed_tickets]

executor.store_artifact(
    identifier="prioritized_tickets",
    title="Prioritized Open Support Tickets",
    artifact_type="table",
    data=sorted_ticket_ids
)

# For debugging, we can print out the sorted list of ticket IDs.
executor.print("Sorted Ticket IDs based on priority:")
executor.print(str(sorted_ticket_ids))

</pre></div><div class="section-title">Code Output:</div><button class="collapsible">Show Code Output +</button><div class="content"><pre>SQL statement returned 10 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 3 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 3 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 3 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 3 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 3 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 4 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 3 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 10 items
Stored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Open Support Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 287}]
Sorted Ticket IDs based on priority:
[{'ticket_id': 143}, {'ticket_id': 287}, {'ticket_id': 286}, {'ticket_id': 169}, {'ticket_id': 166}, {'ticket_id': 139}, {'ticket_id': 288}, {'ticket_id': 209}, {'ticket_id': 251}, {'ticket_id': 289}]

</pre></div></div><div class='message assistant'><strong>Assistant:</strong><pre>Here is your sorted list of prioritized ticket IDs:
<artifact identifier="prioritized_tickets" />
</pre></div><div style='width: 100%;'><div class='separator'></div><div class='result-section'><div class='section-title'>Result:</div><pre>[
  {
    "ticket_id": 143
  },
  {
    "ticket_id": 287
  },
  {
    "ticket_id": 286
  },
  {
    "ticket_id": 169
  },
  {
    "ticket_id": 166
  },
  {
    "ticket_id": 139
  },
  {
    "ticket_id": 288
  },
  {
    "ticket_id": 209
  },
  {
    "ticket_id": 251
  },
  {
    "ticket_id": 289
  }
]</pre></div></div></div></div><div class='system-column'><div class='sticky-header'><h3 class='system-title'>tool_calling</h3></div><div class='system'><p>Run not found</p></div></div><div class='system-column'><div class='sticky-header'><h3 class='system-title'>tool_calling_python</h3></div><div class='system'><p>Run not found</p></div></div></div></div><div id='run-3' class='tab-content'><div class='container'><div class='system-column'><div class='sticky-header'><h3 class='system-title'>promptql</h3><span class='execution-time'>(Execution time: 1m 9s)</span></div><div class='system'><div class='message user'><strong>User:</strong><pre>Give me a sorted list of last 10 open (status = 'open') support tickets according to how I should prioritize them. 

For each ticket do the following:
- get the description of the ticket
- intelligently (without heuristics) extract the project ID from the ticket description. project IDs are UUIDs
- get the plan the project is most recently on
- get the total amount of revenue generated by the project (include invoice items of all types)
- get the email of the user creating the ticket
- get the total amount of revenue generated by all projects of the user (irrespective of whether those projects had support tickets or not)
- get the created at time of the ticket
- intelligently (without heuristics) classify the ticket into one of these categories: downtime, reliability, performance, bug, feature request, others.

Category descriptions for AI Classification instructions:

1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production environment outages and API failures, with reports of 500 errors and timeouts when attempting to connect to services.

2. Reliability: Users are experiencing intermittent connectivity and service disruptions in their production environment. The issues manifest as random request failures, service instability or intermittent errors, affecting system reliability and user experience.

3. Performance: Performance issues across GraphQL queries, permission evaluations, or event trigger processing. Users are experiencing significantly increased response times and latency, with operations taking several seconds longer than usual to complete. 

4. Bug: Users are reporting bugs in the behaviour of software e.g. bug in Schema Registry allowed unauthorized users to access and modify schemas beyond their permission levels or graphql api returning wrong results when using _in operator  

5. Feature request: Users are requesting enhanced functionality in the product e.g. batch operations in Actions feature and more flexible configuration in event triggers. 

6. Others: Any other type of ticket which does not fit the above categories

- Then sort the tickets in order of priority using the following scoring:

1. Category Weight (0-25 points):
- Downtime: 25 points
- Reliability: 20 points
- Performance: 15 points
- Bug: 10 points
- Feature Request: 5 points
- Others: 0 points

2. Plan Weight (0-15 points):
- advanced: 15 points
- base: 10 points
- free: 0 points

3. Revenue Impact (0-40 points total):
- Project Revenue: Up to 20 points (scaled relative to highest project revenue)
- User Total Revenue: Up to 20 points (scaled relative to highest user revenue)

4. Age (0-20 points):
Linear scale where:
- Newest ticket = 20 points
- Oldest ticket = 0 points
- Other tickets scaled linearly between these points

- Respond with an artifact with identifier "prioritized_tickets" containing sorted list of ticket IDs in the following format:
[
    {
      "ticket_id": 1,
    },
    ...
]
</pre></div><div class='message assistant'><strong>Assistant:</strong><pre>Let’s break the task into the following steps:

1. Query the most recent 10 open tickets from the support tickets table.
2. For each ticket, we:
   • Extract the project ID from the description (using the standard UUID format).
   • Get the latest plan record (if no record is found, assume a “free” plan).
   • Calculate the project’s total revenue (summing all invoice items for that project).
   • Get the email of the requester (from the support_user table using the ticket’s requester_id).
   • Calculate the total revenue for all projects of that user (joining projects with users by email).
3. Use the classification AI to categorize each ticket (using the provided category descriptions).
4. Compute ticket priority scores with these components:
   • Category Weight: based on the classification.
   • Plan Weight: “advanced” (15), “base” (10), “free” (0).
   • Revenue Impact:
  – Project Revenue score: Up to 20 points (scaled by the highest project revenue among the 10 tickets).
  – User Total Revenue score: Up to 20 points (scaled by the highest user revenue among the 10 tickets).
   • Age Score: Newest ticket gets 20, oldest gets 0, with linear scaling in between.
5. Sum the scores and sort the tickets by total score descending.
6. Finally, return an artifact with the sorted list of ticket IDs in the prescribed format.

Let’s now proceed with this plan.

</pre><div class="section-title">Plan:</div><pre>1. Retrieve the last 10 open support tickets (fields: id, description, created_at, requester_id).
2. For each ticket:
   a. Extract the project ID using a UUID regular expression.
   b. Query the latest project plan for that project. Joining the project_plan_changelogs and plans tables, order by created_at descending, limit to one result. If nothing is found, set plan to "free".
   c. Sum up the project’s revenue from invoice_item table for the project.
   d. Get the support user email from support_user table using the requester_id.
   e. Compute the total revenue for all projects of the user by joining invoice_item, projects, and users (matching on the user's email).
3. Use the "classify" AI function on the ticket descriptions (with provided category definitions) to determine the ticket category.
4. Compute each ticket’s priority score based on:
   - Category Weight: downtime (25), reliability (20), performance (15), bug (10), feature request (5), others (0).
   - Plan Weight: advanced (15), base (10), free (0).
   - Revenue Impact: For project revenue and user total revenue, compute each ticket’s score out of 20 points relative to the maximum in the sample.
   - Age: Compute age score by linearly interpolating between the newest (20 points) and oldest (0 points) ticket (using created_at timestamps).
5. Sort the tickets descending by total score.
6. Finally, create an artifact "prioritized_tickets" with the sorted list of ticket IDs as:
   [
       { "ticket_id": <id> },
       … 
   ]
Assumptions:
- All ticket descriptions include a valid UUID representing the project ID.
- If any lookup (e.g. for a plan or revenues) fails, we use default values (plan “free”, and revenue = 0).

</pre><div class="section-title">Code:</div><button class="collapsible">Show Code +</button><div class="content"><pre>import re
import datetime

# Function to parse a timestamp from string
def parse_timestamp(ts_str):
    # assuming ISO 8601 format from the database (e.g. '2025-02-20T10:43:04.309239')
    return datetime.datetime.fromisoformat(ts_str)

# Step 1: Retrieve the 10 most recent open support tickets
sql_tickets = """
    SELECT id, description, created_at, requester_id
    FROM app.support_ticket
    WHERE status = 'open'
    ORDER BY created_at DESC
    LIMIT 10
"""
tickets = executor.run_sql(sql_tickets)

if not tickets:
    executor.print("No open support tickets found.")
    # Store empty artifact
    executor.store_artifact(
        identifier="prioritized_tickets",
        title="Prioritized Tickets",
        artifact_type="table",
        data=[]
    )
    exit()

# Prepare list to accumulate enhanced ticket info.
enhanced_tickets = []

# Precompile UUID regex pattern.
uuid_regex = re.compile(r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}')

# Loop over each ticket to enrich with additional details.
for ticket in tickets:
    ticket_id = ticket.get("id")
    description = ticket.get("description", "")
    created_at = ticket.get("created_at")
    requester_id = ticket.get("requester_id")
    
    # a. Extract project ID using regex.
    match = uuid_regex.search(description)
    project_id = match.group(0) if match else None
    
    if not project_id:
        # If no project ID is found, we skip this ticket.
        continue

    # b. Query for latest plan for the project.
    sql_plan = f"""
        SELECT p.name AS plan_name, ppc.created_at AS plan_created_at
        FROM app.project_plan_changelogs ppc
        JOIN app.plans p ON ppc.plan_id = p.id
        WHERE ppc.project_id = '{project_id}'
        ORDER BY ppc.created_at DESC
        LIMIT 1
    """
    plan_rows = executor.run_sql(sql_plan)
    if plan_rows and len(plan_rows) > 0:
        plan_name = plan_rows[0].get("plan_name", "free").lower()
    else:
        plan_name = "free"

    # c. Query total project revenue from invoice_item table.
    sql_project_rev = f"""
        SELECT SUM(amount) AS revenue
        FROM app.invoice_item
        WHERE project_id = '{project_id}'
    """
    proj_rev_rows = executor.run_sql(sql_project_rev)
    project_revenue = float(proj_rev_rows[0].get("revenue") or 0) if proj_rev_rows else 0.0

    # d. Get support user email for the requester.
    sql_user_email = f"""
        SELECT email
        FROM app.support_user
        WHERE id = {requester_id}
    """
    user_email_rows = executor.run_sql(sql_user_email)
    user_email = user_email_rows[0].get("email") if user_email_rows else ""

    # e. Get total revenue across all projects for the user.
    # Join invoice_item, projects, and users (matching on users.email = user_email).
    sql_user_total_rev = f"""
        SELECT SUM(ii.amount) AS revenue
        FROM app.invoice_item ii
        JOIN app.projects p ON ii.project_id = p.id
        JOIN app.users u ON p.owner_id = u.id
        WHERE u.email = '{user_email}'
    """
    user_rev_rows = executor.run_sql(sql_user_total_rev)
    user_total_revenue = float(user_rev_rows[0].get("revenue") or 0) if user_rev_rows else 0.0

    # Save enriched ticket info
    enhanced_tickets.append({
        "ticket_id": ticket_id,
        "description": description,
        "created_at": created_at,
        "project_id": project_id,
        "plan_name": plan_name,
        "project_revenue": project_revenue,
        "user_email": user_email,
        "user_total_revenue": user_total_revenue
    })

# If no tickets enriched (e.g. no project IDs found), store empty result.
if not enhanced_tickets:
    executor.print("No enriched tickets available after extracting project IDs.")
    executor.store_artifact(
        identifier="prioritized_tickets",
        title="Prioritized Tickets",
        artifact_type="table",
        data=[]
    )
    exit()

# Step 3: Use AI classification to classify each ticket description.
# Categories and their descriptions as provided.
categories = ['downtime', 'reliability', 'performance', 'bug', 'feature request', 'others']
classification_instructions = """
Classify the following support ticket descriptions into one of these categories:
1. Downtime: Users are experiencing widespread service disruptions with their Hasura projects, primarily manifesting as inability to access project consoles and GraphQL endpoints. These issues are causing production outages and API failures.
2. Reliability: Users are experiencing intermittent connectivity issues and random request failures.
3. Performance: There are significant delays and increased latency in response times.
4. Bug: Reports indicate software malfunction or incorrect behavior.
5. Feature request: Users are requesting enhanced functionality.
6. Others: Does not fit the other categories.
For each description, return exactly one of the above category names.
"""
# Prepare the list of descriptions.
ticket_descriptions = [t["description"] for t in enhanced_tickets]
classifications = executor.classify(
    instructions=classification_instructions,
    categories=categories,
    allow_multiple=False,
    inputs=ticket_descriptions,
)

# Append the classification to each ticket entry.
for idx, ticket in enumerate(enhanced_tickets):
    ticket["category"] = classifications[idx].strip().lower()

# Step 4: Compute score components for each ticket.

# Define weights.
category_weights = {
    "downtime": 25,
    "reliability": 20,
    "performance": 15,
    "bug": 10,
    "feature request": 5,
    "others": 0
}

plan_weights = {
    "advanced": 15,
    "base": 10,
    "free": 0
}

# Determine max values for revenue normalization and age.
max_project_rev = max(t["project_revenue"] for t in enhanced_tickets) or 1
max_user_rev = max(t["user_total_revenue"] for t in enhanced_tickets) or 1

# Parse created_at values to datetime objects.
for ticket in enhanced_tickets:
    ticket["created_at_dt"] = parse_timestamp(ticket["created_at"])

latest_time = max(t["created_at_dt"] for t in enhanced_tickets)
oldest_time = min(t["created_at_dt"] for t in enhanced_tickets)
time_range = (latest_time - oldest_time).total_seconds() or 1  # avoid division by zero

# Now compute total score for each ticket.
for ticket in enhanced_tickets:
    # Category weight (default to 0 if classification does not match)
    cat = ticket["category"]
    ticket["category_weight"] = category_weights.get(cat, 0)
    
    # Plan weight - default to 0 if plan_kind not matched.
    ticket["plan_weight"] = plan_weights.get(ticket["plan_name"], 0)
    
    # Revenue impact: Scale each revenue relative to maximum (up to 20 points).
    ticket["project_rev_score"] = (ticket["project_revenue"] / max_project_rev) * 20
    ticket["user_rev_score"] = (ticket["user_total_revenue"] / max_user_rev) * 20
    
    # Age score: linear scale where newest ticket gets 20, oldest gets 0.
    age_seconds = (ticket["created_at_dt"] - oldest_time).total_seconds()
    ticket["age_score"] = (age_seconds / time_range) * 20
    
    # Total score: sum up all components.
    ticket["total_score"] = (ticket["category_weight"] +
                             ticket["plan_weight"] +
                             ticket["project_rev_score"] +
                             ticket["user_rev_score"] +
                             ticket["age_score"])

# Step 5: Sort the tickets in descending order based on total score.
sorted_tickets = sorted(enhanced_tickets, key=lambda x: x["total_score"], reverse=True)

# Build the final list with only ticket_id information.
final_output = [{"ticket_id": t["ticket_id"]} for t in sorted_tickets]

# Step 6: Store the prioritized ticket IDs as an artifact.
executor.store_artifact(
    identifier="prioritized_tickets",
    title="Prioritized Tickets",
    artifact_type="table",
    data=final_output
)

executor.print("Prioritized tickets computed and stored.")

</pre></div><div class="section-title">Code Output:</div><button class="collapsible">Show Code Output +</button><div class="content"><pre>SQL statement returned 10 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
SQL statement returned 1 rows.
Classified 10 items
Stored table artifact: identifier = 'prioritized_tickets', title = 'Prioritized Tickets', number of rows = 10, sample rows = [{'ticket_id': 143}, {'ticket_id': 287}]
Prioritized tickets computed and stored.

</pre></div></div><div class='message assistant'><strong>Assistant:</strong><pre>Here is your prioritized list of open support tickets:
<artifact identifier="prioritized_tickets" />
</pre></div><div style='width: 100%;'><div class='separator'></div><div class='result-section'><div class='section-title'>Result:</div><pre>[
  {
    "ticket_id": 143
  },
  {
    "ticket_id": 287
  },
  {
    "ticket_id": 286
  },
  {
    "ticket_id": 169
  },
  {
    "ticket_id": 166
  },
  {
    "ticket_id": 139
  },
  {
    "ticket_id": 209
  },
  {
    "ticket_id": 251
  },
  {
    "ticket_id": 288
  },
  {
    "ticket_id": 289
  }
]</pre></div></div></div></div><div class='system-column'><div class='sticky-header'><h3 class='system-title'>tool_calling</h3></div><div class='system'><p>Run not found</p></div></div><div class='system-column'><div class='sticky-header'><h3 class='system-title'>tool_calling_python</h3></div><div class='system'><p>Run not found</p></div></div></div></div>
    </body>
    </html>
    