[
  {
    "timestamp": "2025-01-29T16:03:45.451589",
    "response": {
      "id": "chatcmpl-AuzfbvXy6t0Hz5mxL7QjSb9q7Oiqi",
      "choices": [
        {
          "finish_reason": "tool_calls",
          "index": 0,
          "logprobs": null,
          "message": {
            "content": null,
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
              {
                "id": "call_oAxdHJeUkZvjAAXa79MzTeH7",
                "function": {
                  "arguments": "{\n  \"pythonCode\": \"#!/usr/bin/env python3\\nimport re\\nimport sys\\nimport json\\nimport datetime\\nfrom functools import cmp_to_key\\n\\n# We'll define a function to parse project id from a string\\n# project IDs are 36-char UUID strings\\nUUID_REGEX = re.compile(r\\\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\\")\\n\\n# We'll define a function to classify the ticket based on subject and description.\\n# We'll combine them for classification.\\n\\ndef classify_ticket(text: str) -> str:\\n    \\\"\\\"\\\"\\n    Classification instructions:\\n    1. downtime: references to widespread inability to access project console, 500 errors, timeouts, disruptions\\n    2. reliability: references to intermittent connectivity, random failures\\n    3. performance: references to performance issues, slowdown, high latency\\n    4. bug: references to a bug in the behavior\\n    5. feature request: references to new feature or enhanced functionality\\n    6. others\\n    \\\"\\\"\\\"\\n    # lowercase text for easier matching\\n    text_l = text.lower()\\n\\n    # We'll do some keyword matching.\\n    if any(keyword in text_l for keyword in [\\\"downtime\\\", \\\"outage\\\", \\\"500 error\\\", \\\"time out\\\", \\\"disruption\\\"]):\\n        return \\\"downtime\\\"\\n    if any(keyword in text_l for keyword in [\\\"reliability\\\", \\\"intermittent\\\", \\\"random failures\\\"]):\\n        return \\\"reliability\\\"\\n    if \\\"performance\\\" in text_l or \\\"latency\\\" in text_l:\\n        return \\\"performance\\\"\\n    if \\\"bug\\\" in text_l:\\n        return \\\"bug\\\"\\n    if \\\"feature request\\\" in text_l or \\\"feature\\\" in text_l:\\n        return \\\"feature request\\\"\\n    # otherwise\\n    return \\\"others\\\"\\n\\n\\ndef get_category_rank(category: str) -> int:\\n    # define category order: downtime (0) > reliability (1) > performance (2) > bug (3) > feature request(4) > others (5)\\n    ordering = {\\n        \\\"downtime\\\": 0,\\n        \\\"reliability\\\": 1,\\n        \\\"performance\\\": 2,\\n        \\\"bug\\\": 3,\\n        \\\"feature request\\\": 4,\\n        \\\"others\\\": 5\\n    }\\n    return ordering.get(category, 5)\\n\\n\\ndef main():\\n    # First, let us fetch the last 5 open tickets from the support tickets DB\\n\\n    import requests, json\\n\\n    # We'll query the support tickets DB\\n    query = \\\"\\\"\\\"\\n    SELECT id, subject, description, created_at\\n    FROM support_ticket\\n    WHERE status = 'open'\\n    ORDER BY created_at DESC\\n    LIMIT 5;\\n    \\\"\\\"\\\"\\n\\n    # We'll call the function query_support_tickets to fetch data\\n    tickets_response = requests.post(\\n        \\\"http://localhost:5000/query_support_tickets\\\",\\n        headers={\\\"Content-Type\\\": \\\"application/json\\\"},\\n        data=json.dumps({\\\"sql\\\": query})\\n    )\\n\\n    if tickets_response.status_code != 200:\\n        print(f\\\"Error querying support_tickets: {tickets_response.text}\\\", file=sys.stderr)\\n        sys.exit(1)\\n\\n    # data is a JSON array\\n    tickets_data = tickets_response.json()\\n\\n    # We'll now parse each ticket, find the project ID, get plan info, classify, etc.\\n\\n    processed_tickets = []\\n\\n    for row in tickets_data:\\n        ticket_id = row[0]\\n        subject = row[1]\\n        description = row[2]\\n        created_at_str = row[3]\\n        created_at = None\\n        try:\\n            # parse created_at\\n            created_at = datetime.datetime.fromisoformat(created_at_str)\\n        except:\\n            # fallback if needed\\n            created_at = None\\n\\n        # parse project id from the description (or subject)\\n        full_text = (subject or \\\"\\\") + \\\"\\\\n\\\" + (description or \\\"\\\")\\n        project_id = None\\n        match = UUID_REGEX.search(full_text)\\n        if match:\\n            project_id = match.group(0)\\n\\n        # now we get the plan for that project from the control plane DB if project_id is found\\n        plan_name = None\\n        if project_id:\\n            plan_query = f\\\"\\\"\\\"\\n            SELECT p.name as plan_name\\n            FROM project_plan_changelogs pc\\n            JOIN plans p ON p.id = pc.plan_id\\n            WHERE pc.project_id = '{project_id}'\\n            ORDER BY pc.created_at DESC\\n            LIMIT 1;\\n            \\\"\\\"\\\"\\n            plan_resp = requests.post(\\n                \\\"http://localhost:5000/query_control_plane_data\\\",\\n                headers={\\\"Content-Type\\\": \\\"application/json\\\"},\\n                data=json.dumps({\\\"sql\\\": plan_query})\\n            )\\n            if plan_resp.status_code == 200:\\n                plan_data = plan_resp.json()\\n                if len(plan_data) > 0:\\n                    plan_name = plan_data[0][0]\\n\\n        # classify the ticket\\n        category = classify_ticket(full_text)\\n\\n        # store the data\\n        processed_tickets.append({\\n            \\\"ticket_id\\\": ticket_id,\\n            \\\"project_id\\\": project_id,\\n            \\\"plan_name\\\": plan_name,\\n            \\\"created_at\\\": created_at,\\n            \\\"category\\\": category\\n        })\\n\\n    # define the sorting rules:\\n    # 1) advanced plan + category in [downtime, reliability] => highest priority\\n    # 2) category order: downtime (0) > reliability(1) > performance(2) > bug(3) > feature request(4) > others(5)\\n    # 3) older tickets first\\n\\n    def ticket_compare(t1, t2):\\n        \\\"\\\"\\\"compare two tickets with the rules\\\"\\\"\\\"\\n        # 1) advanced + downtime/reliability => highest\\n        plans_advanced_set = set([\\\"Advanced\\\", \\\"advanced\\\"])\\n        c1_critical = ( (t1[\\\"plan_name\\\"] in plans_advanced_set) and (t1[\\\"category\\\"] in [\\\"downtime\\\", \\\"reliability\\\"]) )\\n        c2_critical = ( (t2[\\\"plan_name\\\"] in plans_advanced_set) and (t2[\\\"category\\\"] in [\\\"downtime\\\", \\\"reliability\\\"]) )\\n        if c1_critical and not c2_critical:\\n            return -1  # t1 should come before t2\\n        elif c2_critical and not c1_critical:\\n            return 1\\n\\n        # 2) category order\\n        c1_cat = get_category_rank(t1[\\\"category\\\"])\\n        c2_cat = get_category_rank(t2[\\\"category\\\"])\\n        if c1_cat < c2_cat:\\n            return -1\\n        elif c1_cat > c2_cat:\\n            return 1\\n\\n        # 3) older ticket => higher priority => compare created_at ascending\\n        c1_time = t1[\\\"created_at\\\"]\\n        c2_time = t2[\\\"created_at\\\"]\\n        # if one of them is None, let's handle\\n        if c1_time is None and c2_time is not None:\\n            return 1  # put t2 first because it has a valid time\\n        elif c2_time is None and c1_time is not None:\\n            return -1\\n        elif c1_time is None and c2_time is None:\\n            return 0\\n        # both not None\\n        if c1_time < c2_time:\\n            return -1\\n        elif c1_time > c2_time:\\n            return 1\\n        return 0\\n\\n    processed_tickets_sorted = sorted(processed_tickets, key=cmp_to_key(ticket_compare))\\n\\n    # we only want the top 5, but we only have 5 total. Let's just do top 5 anyway\\n    top_tickets = processed_tickets_sorted[:5]\\n\\n    # now we print the result in the requested format\\n    print(\\\"<tickets>\\\")\\n    for t in top_tickets:\\n        print(t[\\\"ticket_id\\\"])\\n    print(\\\"</tickets>\\\")\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"\n}",
                  "name": "execute_python_program"
                },
                "type": "function"
              }
            ]
          }
        }
      ],
      "created": 1738146791,
      "model": "o1-2024-12-17",
      "object": "chat.completion",
      "service_tier": "default",
      "system_fingerprint": "fp_d91c966719",
      "usage": {
        "completion_tokens": 3960,
        "prompt_tokens": 1102,
        "total_tokens": 5062,
        "completion_tokens_details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 2048,
          "rejected_prediction_tokens": 0
        },
        "prompt_tokens_details": {
          "audio_tokens": 0,
          "cached_tokens": 0
        }
      }
    }
  },
  {
    "timestamp": "2025-01-29T16:04:18.338867",
    "response": {
      "id": "chatcmpl-Auzg9sH5QrH4pVlbPi1M2flVcpeRq",
      "choices": [
        {
          "finish_reason": "tool_calls",
          "index": 0,
          "logprobs": null,
          "message": {
            "content": null,
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
              {
                "id": "call_7ntxMizsONyLektImUmT6wBB",
                "function": {
                  "arguments": "{\"pythonCode\":\"#!/usr/bin/env python3\\n# We'll fetch the last 5 open tickets from the support_tickets database\\n# Parse out the project_id from the description or subject if present as a UUID\\n# For each ticket, find the plan from the control plane logs\\n# Then classify ticket by the given categories\\n# Then we sort them using the rules provided\\n# Finally print them in the requested <tickets> format.\\n\\nimport re\\nimport datetime\\nimport json\\nimport requests\\nfrom functools import cmp_to_key\\nimport sys\\n\\nUUID_REGEX = re.compile(r\\\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\\")\\n\\n# Classification function\\n# We'll look for specific keywords in subject/description\\n\\ndef classify_ticket(text: str) -> str:\\n    text_l = text.lower()\\n    # 1. downtime\\n    downtime_keywords = [\\\"downtime\\\", \\\"outage\\\", \\\"500 error\\\", \\\"time out\\\", \\\"disruption\\\"]\\n    if any(k in text_l for k in downtime_keywords):\\n        return \\\"downtime\\\"\\n\\n    # 2. reliability\\n    reliability_keywords = [\\\"reliability\\\", \\\"intermittent\\\", \\\"random failures\\\", \\\"instability\\\"]\\n    if any(k in text_l for k in reliability_keywords):\\n        return \\\"reliability\\\"\\n\\n    # 3. performance\\n    perf_keywords = [\\\"performance\\\", \\\"latency\\\", \\\"slow\\\", \\\"slowness\\\"]\\n    if any(k in text_l for k in perf_keywords):\\n        return \\\"performance\\\"\\n\\n    # 4. bug\\n    # We'll look for 'bug', 'unexpected behavior', etc.\\n    bug_keywords = [\\\"bug\\\", \\\"issue in schema\\\", \\\"wrong results\\\"]\\n    if any(k in text_l for k in bug_keywords):\\n        return \\\"bug\\\"\\n\\n    # 5. feature request\\n    fr_keywords = [\\\"feature request\\\", \\\"request new feature\\\", \\\"enhancement\\\"]\\n    if any(k in text_l for k in fr_keywords):\\n        return \\\"feature request\\\"\\n\\n    # fallback\\n    return \\\"others\\\"\\n\\n# Define ranking for categories\\ncategory_rank = {\\n    \\\"downtime\\\": 0,\\n    \\\"reliability\\\": 1,\\n    \\\"performance\\\": 2,\\n    \\\"bug\\\": 3,\\n    \\\"feature request\\\": 4,\\n    \\\"others\\\": 5\\n}\\n\\n# We'll define our comparator function\\n\\ndef compare_tickets(t1, t2):\\n    # 1) advanced plan + downtime or reliability -> highest priority\\n    advanced_names = {\\\"advanced\\\", \\\"Advanced\\\"}\\n    t1_critical = (t1[\\\"plan_name\\\"] is not None and t1[\\\"plan_name\\\"] in advanced_names and t1[\\\"category\\\"] in [\\\"downtime\\\", \\\"reliability\\\"])\\n    t2_critical = (t2[\\\"plan_name\\\"] is not None and t2[\\\"plan_name\\\"] in advanced_names and t2[\\\"category\\\"] in [\\\"downtime\\\", \\\"reliability\\\"])\\n\\n    if t1_critical and not t2_critical:\\n        return -1\\n    if t2_critical and not t1_critical:\\n        return 1\\n\\n    # 2) category rank\\n    c1 = category_rank.get(t1[\\\"category\\\"], 5)\\n    c2 = category_rank.get(t2[\\\"category\\\"], 5)\\n    if c1 != c2:\\n        return -1 if c1 < c2 else 1\\n\\n    # 3) older ticket => higher priority, so ascending by created_at\\n    d1 = t1[\\\"created_at\\\"]\\n    d2 = t2[\\\"created_at\\\"]\\n    if d1 is None and d2 is not None:\\n        return 1  # t2 is older\\n    elif d2 is None and d1 is not None:\\n        return -1\\n    elif d1 is None and d2 is None:\\n        return 0\\n    else:\\n        if d1 < d2:\\n            return -1\\n        elif d1 > d2:\\n            return 1\\n        else:\\n            return 0\\n\\n\\ndef main():\\n    # Step 1: fetch the last 5 open tickets\\n    sql = \\\"\\\"\\\"\\n    SELECT id, subject, description, created_at\\n    FROM support_ticket\\n    WHERE status = 'open'\\n    ORDER BY created_at DESC\\n    LIMIT 5;\\n    \\\"\\\"\\\"\\n\\n    try:\\n        resp = requests.post(\\n            \\\"http://localhost:5000/query_support_tickets\\\",\\n            headers={\\\"Content-Type\\\": \\\"application/json\\\"},\\n            data=json.dumps({\\\"sql\\\": sql})\\n        )\\n        resp.raise_for_status()\\n        rows = resp.json()\\n    except Exception as e:\\n        print(\\\"Error fetching tickets:\\\", e, file=sys.stderr)\\n        # We'll simulate no data\\n        rows = []\\n\\n    tickets = []\\n\\n    for row in rows:\\n        ticket_id = row[0]\\n        subject = row[1] or \\\"\\\"\\n        description = row[2] or \\\"\\\"\\n        created_at_str = row[3]\\n        try:\\n            created_at = datetime.datetime.fromisoformat(created_at_str)\\n        except:\\n            created_at = None\\n        full_text = subject + \\\"\\\\n\\\" + description\\n        match = UUID_REGEX.search(full_text)\\n        project_id = match.group(0) if match else None\\n\\n        # get plan if we have a project_id\\n        plan_name = None\\n        if project_id:\\n            sql2 = f\\\"\\\"\\\"\\n            SELECT p.name\\n            FROM project_plan_changelogs pc\\n            JOIN plans p ON p.id = pc.plan_id\\n            WHERE pc.project_id = '{project_id}'\\n            ORDER BY pc.created_at DESC\\n            LIMIT 1;\\n            \\\"\\\"\\\"\\n            try:\\n                resp2 = requests.post(\\n                    \\\"http://localhost:5000/query_control_plane_data\\\",\\n                    headers={\\\"Content-Type\\\": \\\"application/json\\\"},\\n                    data=json.dumps({\\\"sql\\\": sql2})\\n                )\\n                if resp2.status_code == 200:\\n                    data2 = resp2.json()\\n                    if data2:\\n                        plan_name = data2[0][0]\\n            except Exception as e:\\n                print(\\\"Error fetching plan:\\\", e, file=sys.stderr)\\n\\n        category = classify_ticket(full_text)\\n        tickets.append({\\n            \\\"ticket_id\\\": ticket_id,\\n            \\\"subject\\\": subject,\\n            \\\"description\\\": description,\\n            \\\"project_id\\\": project_id,\\n            \\\"plan_name\\\": plan_name,\\n            \\\"created_at\\\": created_at,\\n            \\\"category\\\": category\\n        })\\n\\n    # do the sorting\\n    tickets_sorted = sorted(tickets, key=cmp_to_key(compare_tickets))\\n\\n    # take top 5\\n    top_5 = tickets_sorted[:5]\\n\\n    print(\\\"<tickets>\\\")\\n    for t in top_5:\\n        print(t[\\\"ticket_id\\\"])\\n    print(\\\"</tickets>\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"}",
                  "name": "execute_python_program"
                },
                "type": "function"
              }
            ]
          }
        }
      ],
      "created": 1738146825,
      "model": "o1-2024-12-17",
      "object": "chat.completion",
      "service_tier": "default",
      "system_fingerprint": "fp_d91c966719",
      "usage": {
        "completion_tokens": 3845,
        "prompt_tokens": 4438,
        "total_tokens": 8283,
        "completion_tokens_details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 2176,
          "rejected_prediction_tokens": 0
        },
        "prompt_tokens_details": {
          "audio_tokens": 0,
          "cached_tokens": 0
        }
      }
    }
  },
  {
    "timestamp": "2025-01-29T16:04:24.768500",
    "response": {
      "id": "chatcmpl-Auzgg6dQ0NkfSzDDwZG5aftSGca6Q",
      "choices": [
        {
          "finish_reason": "stop",
          "index": 0,
          "logprobs": null,
          "message": {
            "content": "<tickets>\n</tickets>",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
          }
        }
      ],
      "created": 1738146858,
      "model": "o1-2024-12-17",
      "object": "chat.completion",
      "service_tier": "default",
      "system_fingerprint": "fp_d91c966719",
      "usage": {
        "completion_tokens": 593,
        "prompt_tokens": 6202,
        "total_tokens": 6795,
        "completion_tokens_details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 576,
          "rejected_prediction_tokens": 0
        },
        "prompt_tokens_details": {
          "audio_tokens": 0,
          "cached_tokens": 4352
        }
      }
    }
  }
]